From e4bb6c11845f258dd06302486a57126b9072006b Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Sun, 30 Jan 2022 11:50:22 +0100
Subject: [PATCH 01/29] wip: port to python 3.10 -- probably unfixable

---
 parser/astbuilder.cpp                    | 12 ++++++------
 parser/conversionGenerator.py            | 12 +++++++++---
 parser/generated.h                       |  8 +++++++-
 parser/{python39.sdef => python310.sdef} |  0
 parser/python_header.h                   | 14 +++++++-------
 5 files changed, 29 insertions(+), 17 deletions(-)
 rename parser/{python39.sdef => python310.sdef} (100%)

diff --git a/parser/astbuilder.cpp b/parser/astbuilder.cpp
index ce652c7b..d15879ab 100644
--- a/parser/astbuilder.cpp
+++ b/parser/astbuilder.cpp
@@ -23,7 +23,6 @@
 #include "parserdebug.h"
 
 using namespace KDevelop;
-extern grammar _PyParser_Grammar;
 
 namespace Python
 {
@@ -60,13 +59,13 @@ struct PythonInitializer : private QMutexLocker {
             Py_InitializeEx(0);
             Q_ASSERT(Py_IsInitialized());
 
-            arena = PyArena_New();
+            arena = _PyArena_New();
             Q_ASSERT(arena); // out of memory
     }
     ~PythonInitializer()
     {
         if (arena)
-            PyArena_Free(arena);
+            _PyArena_Free(arena);
         if (Py_IsInitialized())
             Py_Finalize();
     }
@@ -100,7 +99,8 @@ CodeAst::Ptr AstBuilder::parse(const QUrl& filename, QString &contents)
         contents = cythonSyntaxRemover.stripCythonSyntax(contents);
     }
 
-    mod_ty syntaxtree = PyParser_ASTFromString(contents.toUtf8().data(), "<kdev-editor-contents>", file_input, &flags, arena);
+    std::unique_ptr<PyObject> placeholderFilename(PyUnicode_FromString("<kdev-editor-contents>"));
+    mod_ty syntaxtree = _PyParser_ASTFromString(contents.toUtf8().data(), placeholderFilename.get(), Py_file_input, &flags, arena);
 
     if ( ! syntaxtree ) {
         qCDebug(KDEV_PYTHON_PARSER) << " ====< parse error, trying to fix";
@@ -207,7 +207,7 @@ CodeAst::Ptr AstBuilder::parse(const QUrl& filename, QString &contents)
             }
         }
 
-        syntaxtree = PyParser_ASTFromString(contents.toUtf8(), "<kdev-editor-contents>", file_input, &flags, arena);
+        syntaxtree = _PyParser_ASTFromString(contents.toUtf8(), placeholderFilename.get(), Py_file_input, &flags, arena);
         // 3rd try: discard everything after the last non-empty line, but only until the next block start
         currentLineBeginning = qMin(contents.length() - 1, currentLineBeginning);
         errline = qMax(0, qMin(indents.length()-1, errline));
@@ -249,7 +249,7 @@ CodeAst::Ptr AstBuilder::parse(const QUrl& filename, QString &contents)
                 if ( c.isSpace() && atLineBeginning ) currentIndent += 1;
             }
             qCDebug(KDEV_PYTHON_PARSER) << "This is what is left: " << contents;
-            syntaxtree = PyParser_ASTFromString(contents.toUtf8(), "<kdev-editor-contents>", file_input, &flags, arena);
+            syntaxtree = _PyParser_ASTFromString(contents.toUtf8(), placeholderFilename.get(), Py_file_input, &flags, arena);
         }
         if ( ! syntaxtree ) {
             return CodeAst::Ptr(); // everything fails, so we abort.
diff --git a/parser/conversionGenerator.py b/parser/conversionGenerator.py
index 8ff1909c..45c3e489 100644
--- a/parser/conversionGenerator.py
+++ b/parser/conversionGenerator.py
@@ -9,7 +9,7 @@
 
 import sys
 
-contents = open('python39.sdef').read().replace("\n", "").split(';;')
+contents = open('python310.sdef').read().replace("\n", "").split(';;')
 
 func_structure = '''
     Ast* visitNode(%{RULE_FOR}* node) {
@@ -64,7 +64,11 @@ assign_linetransform = '''              v->%{TARGET} = tline(node->%{VALUE} - 1)
 singleton_convert_line = '''                v->%{TARGET} = node->v.NameConstant.value == Py_None ? NameConstantAst::None : node->v.NameConstant.value == Py_False ? NameConstantAst::False : NameConstantAst::True;'''
 resolve_oplist_block = '''
                 for ( int _i = 0; _i < node->v.%{KIND_W/O_SUFFIX}.%{VALUE}->size; _i++ ) {
+                    #if PYTHON_VERSION < QT_VERSION_CHECK(3, 10, 0)
                     v->%{TARGET}.append((ExpressionAst::%{AST_TYPE}) node->v.%{KIND_W/O_SUFFIX}.%{VALUE}->elements[_i]);
+                    #else
+                    v->%{TARGET}.append((ExpressionAst::%{AST_TYPE}) node->v.%{KIND_W/O_SUFFIX}.%{VALUE}->typed_elements[_i]);
+                    #endif
                 }
 '''
 resolve_identifier_block = '''
@@ -227,7 +231,9 @@ for rule in contents:
     results[rule_for].append(current_stmt)
     does_match_any[rule_for] = any
 
-print('''/* This code is generated by conversiongenerator.py.
+print('''#pragma once
+
+/* This code is generated by conversiongenerator.py.
  * I do not recommend editing it.
  * To update, run: python2 conversionGenerator.py > generated.h
  */
@@ -261,7 +267,7 @@ private:
         return nodeStack.top();
     }
     
-    template<typename T, typename K> QList<K*> visitNodeList(asdl_seq* node) {
+    template<typename T, typename K, typename Seq> QList<K*> visitNodeList(Seq* node) {
         QList<K*> nodelist;
         if ( ! node ) return nodelist;
         for ( int i=0; i < node->size; i++ ) {
diff --git a/parser/generated.h b/parser/generated.h
index 44a75e9a..43077831 100644
--- a/parser/generated.h
+++ b/parser/generated.h
@@ -1,3 +1,5 @@
+#pragma once
+
 /* This code is generated by conversiongenerator.py.
  * I do not recommend editing it.
  * To update, run: python2 conversionGenerator.py > generated.h
@@ -32,7 +34,7 @@ private:
         return nodeStack.top();
     }
     
-    template<typename T, typename K> QList<K*> visitNodeList(asdl_seq* node) {
+    template<typename T, typename K, typename Seq> QList<K*> visitNodeList(Seq* node) {
         QList<K*> nodelist;
         if ( ! node ) return nodelist;
         for ( int i=0; i < node->size; i++ ) {
@@ -263,7 +265,11 @@ private:
                 nodeStack.push(v); v->leftmostElement = static_cast<ExpressionAst*>(visitNode(node->v.Compare.left)); nodeStack.pop();
 
                 for ( int _i = 0; _i < node->v.Compare.ops->size; _i++ ) {
+                    #if PYTHON_VERSION < QT_VERSION_CHECK(3, 10, 0)
                     v->operators.append((ExpressionAst::ComparisonOperatorTypes) node->v.Compare.ops->elements[_i]);
+                    #else
+                    v->operators.append((ExpressionAst::ComparisonOperatorTypes) node->v.Compare.ops->typed_elements[_i]);
+                    #endif
                 }
 
                 nodeStack.push(v); v->comparands = visitNodeList<_expr, ExpressionAst>(node->v.Compare.comparators); nodeStack.pop();
diff --git a/parser/python39.sdef b/parser/python310.sdef
similarity index 100%
rename from parser/python39.sdef
rename to parser/python310.sdef
diff --git a/parser/python_header.h b/parser/python_header.h
index 0ef792e5..83c6954f 100644
--- a/parser/python_header.h
+++ b/parser/python_header.h
@@ -8,6 +8,8 @@
 #undef _POSIX_C_SOURCE
 #undef _XOPEN_SOURCE
 
+#define Py_BUILD_CORE
+
 // remove interfering qt macro
 #undef slots
 
@@ -17,20 +19,18 @@
 #ifndef _WIN32
 #include "pyconfig.h"
 #endif
-#include "node.h"
 
 #include "Python.h"
 
-#include "Python-ast.h"
+#include <internal/pycore_ast.h>
 #include "ast.h"
 
-#include "graminit.h"
-#include "grammar.h"
-#include "parsetok.h"
+#include <internal/pycore_ast_state.h>
+#include <internal/pycore_parser.h>
 
-#include "unicodeobject.h"
+#include <unicodeobject.h>
 
-#include "object.h"
+#include <object.h>
 
 // remove evil macros from headers which pollute the namespace (grr!)
 #undef test
-- 
GitLab


From ccd917b1b054cd96533b5c06664940ea536022ed Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Sun, 13 Mar 2022 21:14:13 +0100
Subject: [PATCH 02/29] wip: deserialize ast from xml

---
 duchain/tests/pyduchaintest.cpp |   1 +
 parser/CMakeLists.txt           |   1 +
 parser/ast.cpp                  |   2 +
 parser/ast.h                    |   1 +
 parser/ast2xml.py               |  49 ++++++
 parser/astbuilder.cpp           |  52 +++----
 parser/astfromxml.cpp           | 262 ++++++++++++++++++++++++++++++++
 parser/astfromxml.h             |  14 ++
 parser/tests/pyasttest.cpp      |   1 +
 9 files changed, 354 insertions(+), 29 deletions(-)
 create mode 100644 parser/ast2xml.py
 create mode 100644 parser/astfromxml.cpp
 create mode 100644 parser/astfromxml.h

diff --git a/duchain/tests/pyduchaintest.cpp b/duchain/tests/pyduchaintest.cpp
index 7b166fd6..71f6e427 100644
--- a/duchain/tests/pyduchaintest.cpp
+++ b/duchain/tests/pyduchaintest.cpp
@@ -627,6 +627,7 @@ void PyDUChainTest::testSimple_data()
     QTest::addColumn<int>("decls");
     QTest::addColumn<int>("uses");
     
+    QTest::newRow("assign_name") << "a = b;" << 1 << 0;
     QTest::newRow("assign") << "b = 2;" << 1 << 0;
     QTest::newRow("assign_str") << "b = 'hola';" << 1 << 0;
     QTest::newRow("op") << "a = 3; b = a+2;" << 2 << 1;
diff --git a/parser/CMakeLists.txt b/parser/CMakeLists.txt
index 0b83b165..3573b6d1 100644
--- a/parser/CMakeLists.txt
+++ b/parser/CMakeLists.txt
@@ -7,6 +7,7 @@ set(parser_STAT_SRCS
     astbuilder.cpp
     cythonsyntaxremover.cpp
     rangefixvisitor.cpp
+    astfromxml.cpp
 )
 ecm_qt_declare_logging_category(parser_STAT_SRCS
     HEADER parserdebug.h
diff --git a/parser/ast.cpp b/parser/ast.cpp
index 08669964..4d47efe9 100644
--- a/parser/ast.cpp
+++ b/parser/ast.cpp
@@ -80,6 +80,8 @@ ClassDefinitionAst::ClassDefinitionAst(Ast* parent): StatementAst(parent, Ast::C
     
 }
 
+CodeAst::CodeAst(Ast*) : CodeAst() {};
+
 CodeAst::CodeAst() : Ast(nullptr, Ast::CodeAstType), name(nullptr)
 {
 }
diff --git a/parser/ast.h b/parser/ast.h
index e6cf2d58..5d216b69 100644
--- a/parser/ast.h
+++ b/parser/ast.h
@@ -244,6 +244,7 @@ public:
 // this replaces ModuleAst
 class KDEVPYTHONPARSER_EXPORT CodeAst : public Ast {
 public:
+    CodeAst(Ast* parent); // just for compatibility, should never have a parent
     CodeAst();
     ~CodeAst();
     typedef QSharedPointer<CodeAst> Ptr;
diff --git a/parser/ast2xml.py b/parser/ast2xml.py
new file mode 100644
index 00000000..93c9ce6c
--- /dev/null
+++ b/parser/ast2xml.py
@@ -0,0 +1,49 @@
+#!/usr/bin/env python
+
+import ast
+from lxml import etree
+from io import BytesIO
+
+plain_types = (type(0), type(""), type(0.0), type(False), type(None))
+list_type = type([])
+
+class ASTSerializer(ast.NodeVisitor):
+    def __init__(self, xf):
+        self.xf = xf
+
+    def generic_visit(self, node):
+        print("visiting node", node)
+        name = type(node).__name__
+        attrs = {k: getattr(node, k) for k in node._fields}
+        plain_attrs = {k: str(v) for k, v in attrs.items() if type(v) in plain_types}
+        other_attrs = {k: v for k, v in attrs.items() if type(v) not in plain_types}
+        print("\tplain attrs:", plain_attrs)
+        print("\tother attrs:", other_attrs)
+        with xf.element(name, **plain_attrs) as elem:
+            for attrName, attrValue in other_attrs.items():
+                with xf.element(attrName):
+                    if type(attrValue) == list_type:
+                        print("visiting list name", attrName)
+                        print(attrValue)
+                        for node in attrValue:
+                            self.generic_visit(node)
+                    else:
+                        self.generic_visit(attrValue)
+
+
+m = ast.parse("""
+a = 3
+b = 5
+def func(x: int, *args, **kwargs):
+    c = x
+    if 3 < 5 < 7:
+        yield
+    if c is not None:
+        return {x: v for x, v in c}
+""")
+
+f = BytesIO()
+with etree.xmlfile(f) as xf:
+    v = ASTSerializer(xf)
+    v.visit(m)
+print(f.getvalue().decode('utf-8'))
diff --git a/parser/astbuilder.cpp b/parser/astbuilder.cpp
index d15879ab..fa58e658 100644
--- a/parser/astbuilder.cpp
+++ b/parser/astbuilder.cpp
@@ -18,6 +18,7 @@
 #include "astdefaultvisitor.h"
 #include "cythonsyntaxremover.h"
 #include "rangefixvisitor.h"
+#include "astfromxml.h"
 
 #include <QDebug>
 #include "parserdebug.h"
@@ -77,31 +78,29 @@ CodeAst::Ptr AstBuilder::parse(const QUrl& filename, QString &contents)
 {
     qCDebug(KDEV_PYTHON_PARSER) << " ====> AST     ====>     building abstract syntax tree for " << filename.path();
     
-    Py_NoSiteFlag = 1;
-    
     contents.append('\n');
-    
-    PythonInitializer pyIniter(pyInitLock);
-    PyArena* arena = pyIniter.arena;
+    auto xml = R"(<?xml version="1.0"?>
+    <Module>
+    <body>
+    <Assign col_offset="0" lineno="2">
+    <targets>
+    <Name id="a" col_offset="0" lineno="2"/>
+    </targets>
+    <value>
+    <Name id="b" col_offset="4" lineno="2"/>
+    </value>
+    </Assign>
+    </body>
+    <type_ignores/>
+    </Module>
+    )";
 
-#if PYTHON_VERSION >= QT_VERSION_CHECK(3, 8, 0)
-    PyCompilerFlags flags;
-    flags.cf_flags = PyCF_SOURCE_IS_UTF8 | PyCF_IGNORE_COOKIE | PyCF_ONLY_AST;
-    flags.cf_feature_version = PYTHON_VERSION_MINOR;
-#else
-    PyCompilerFlags flags = {PyCF_SOURCE_IS_UTF8 | PyCF_IGNORE_COOKIE};
-#endif
+    qDebug() << "using xml:" << xml;
 
-    CythonSyntaxRemover cythonSyntaxRemover;
-
-    if (filename.fileName().endsWith(".pyx", Qt::CaseInsensitive)) {
-        qCDebug(KDEV_PYTHON_PARSER) << filename.fileName() << "is probably Cython file.";
-        contents = cythonSyntaxRemover.stripCythonSyntax(contents);
-    }
-
-    std::unique_ptr<PyObject> placeholderFilename(PyUnicode_FromString("<kdev-editor-contents>"));
-    mod_ty syntaxtree = _PyParser_ASTFromString(contents.toUtf8().data(), placeholderFilename.get(), Py_file_input, &flags, arena);
+    auto* ast = astFromXml(xml);
+    ast->name = new Identifier(filename.fileName());
 
+#if 0
     if ( ! syntaxtree ) {
         qCDebug(KDEV_PYTHON_PARSER) << " ====< parse error, trying to fix";
 
@@ -255,17 +254,12 @@ CodeAst::Ptr AstBuilder::parse(const QUrl& filename, QString &contents)
             return CodeAst::Ptr(); // everything fails, so we abort.
         }
     }
-    qCDebug(KDEV_PYTHON_PARSER) << "Got syntax tree from python parser:" << syntaxtree->kind << Module_kind;
-
-    PythonAstTransformer t;
-    t.run(syntaxtree, filename.fileName().replace(".py", ""));
+#endif
 
     RangeFixVisitor fixVisitor(contents);
-    fixVisitor.visitNode(t.ast);
-
-    cythonSyntaxRemover.fixAstRanges(t.ast);
+    fixVisitor.visitNode(ast);
 
-    return CodeAst::Ptr(t.ast);
+    return CodeAst::Ptr(ast);
 }
 
 }
diff --git a/parser/astfromxml.cpp b/parser/astfromxml.cpp
new file mode 100644
index 00000000..787067bf
--- /dev/null
+++ b/parser/astfromxml.cpp
@@ -0,0 +1,262 @@
+#include "astfromxml.h"
+
+#include <initializer_list>
+#include <type_traits>
+
+#include <QList>
+
+using namespace Python;
+
+using StringList = std::initializer_list<const char*>;
+template<int Attr> using AttributeTag = std::integral_constant<int, Attr>;
+template<int Child> using ChildTag = std::integral_constant<int, Child>;
+
+using Stream = QXmlStreamReader;
+
+enum global_attributes {col_offset = -1, lineno = -2, last_global_attribute = lineno};
+StringList global_attribute_names = {"col_offset", "lineno"};
+
+template<typename Attributes, int AttributeCount, typename Children, int ChildCount, typename Reader>
+struct NodeReadHelper {
+    constexpr NodeReadHelper(Reader* r, StringList attributeNames, StringList childNames)
+        : r(r)
+        , attributeNames(attributeNames)
+        , childNames(childNames)
+    {
+    }
+
+    template<int N>
+    void tryReadAttributes(QStringRef const& attributeName, QStringRef const& attributeValue) {
+        if constexpr (N >= 0) {
+            if (attributeName == *(r->AttributeNames.begin() + N)) {
+                r->readAttribute(AttributeTag<N>{}, attributeValue);
+                return;
+            }
+        }
+        else {
+            if (attributeName == *(global_attribute_names.begin() - (N+1))) {
+                r->readGlobalAttribute(AttributeTag<N>{}, attributeValue);
+                return;
+            }
+        }
+
+        if constexpr (N > last_global_attribute)
+            tryReadAttributes<N-1>(attributeName, attributeValue);
+        if constexpr (N == last_global_attribute)
+            qWarning() << "failed to match xml attribute name:" << attributeName;
+    }
+
+    void readAttributes(Stream& s) {
+        if constexpr (AttributeCount > 0) {
+            auto const& attributes = s.attributes();
+            for (auto const& attr: attributes) {
+                qDebug() << "read attribute:" << attr.name() << attr.value();
+                tryReadAttributes<AttributeCount - 1>(attr.name(), attr.value());
+            }
+        }
+    }
+
+    template<int N>
+    void readSingleChild(QStringRef const& childName, Stream& s) {
+        auto const nameMatches = childName == *(r->ChildNames.begin() + N);
+        qDebug() << "checking child name:" << nameMatches << childName << *(r->ChildNames.begin() + N) << N;
+        if (nameMatches) {
+            r->readChild(ChildTag<N>{}, s);
+        }
+        else {
+            if constexpr (N > 0)
+                readSingleChild<N-1>(childName, s);
+            if constexpr (N == 0)
+                qWarning() << "failed to match xml child attribute:" << childName;
+        }
+    }
+
+    void readChildren(Stream& s) {
+        if constexpr (ChildCount > 0) {
+            qDebug() << " >> starting read list";
+            while (s.readNextStartElement()) {
+                qDebug() << "read node attribute child:" << s.name();
+                readSingleChild<ChildCount - 1>(s.name(), s);
+            }
+            qDebug() << " << finished read list:" << s.name();
+        }
+    };
+
+    Reader* r;
+    const StringList attributeNames, childNames;
+};
+
+template<typename Derived>
+void doReadNode(Derived* r, Stream& s)
+{
+    using ThisReader = NodeReadHelper<
+        typename Derived::Attributes, Derived::AttributeNames.size(),
+        typename Derived::Children, Derived::ChildNames.size(),
+        Derived
+    >;
+
+    ThisReader reader(r, r->AttributeNames, r->ChildNames);
+    reader.readAttributes(s);
+    reader.readChildren(s);
+}
+
+template<typename AstT>
+struct NodeReader
+{
+};
+
+template<typename AstT>
+struct BaseNodeReader
+{
+    using Children = enum {};
+    using Attributes = enum {};
+
+    static constexpr StringList ChildNames = {};
+    static constexpr StringList AttributeNames = {};
+
+    AstT* read(Stream& s) {
+        using Derived = NodeReader<AstT>;
+        auto* derivedInstance = static_cast<Derived*>(this);
+        doReadNode<Derived>(derivedInstance, s);
+        return derivedInstance->result;
+    }
+
+    void readGlobalAttribute(AttributeTag<col_offset>, QStringRef const& value) {
+        result->startCol = value.toInt();
+    }
+
+    void readGlobalAttribute(AttributeTag<lineno>, QStringRef const& value) {
+        result->startLine = value.toInt();
+    }
+
+    AstT* result;
+
+    BaseNodeReader(Ast* parent) {
+        result = new AstT(parent);
+    }
+};
+
+
+Ast* getSinglElement(Stream& s);
+
+template<typename AstT>
+void listFromXml(Ast* parent, QList<AstT*>& ret, Stream& s);
+
+template<typename AstT>
+void singleFromXml(Ast* parent, AstT*& ret, Stream& s);
+
+/////////////////////////////////////
+
+template<>
+struct NodeReader<NameAst> : public BaseNodeReader<NameAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Attributes = enum { identifier };
+    static auto constexpr AttributeNames = {"id"};
+
+    void readAttribute(AttributeTag<identifier>, QStringRef const& value) {
+        result->identifier = new Identifier(value.toString());
+    }
+};
+
+template<>
+struct NodeReader<AssignmentAst> : public BaseNodeReader<AssignmentAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { targets, value };
+    static auto constexpr ChildNames = {"targets", "value"};
+
+    void readChild(ChildTag<targets>, Stream& s) {
+        listFromXml(result, result->targets, s);
+    }
+
+    void readChild(ChildTag<value>, Stream& s) {
+        singleFromXml(result, result->value, s);
+    }
+};
+
+template<>
+struct NodeReader<CodeAst> : public BaseNodeReader<CodeAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { body };
+    static auto constexpr ChildNames = {"body"};
+
+    void readChild(ChildTag<body>, Stream& s) {
+        listFromXml(result, result->body, s);
+    }
+};
+
+/////////////////////////////////////
+
+QMap<QString, Ast::AstType> astTypes = {
+    {QStringLiteral("Module"), Ast::CodeAstType},
+    {QStringLiteral("Assign"), Ast::AssignmentAstType},
+    {QStringLiteral("Name"), Ast::NameAstType}
+};
+
+Ast::AstType astTypeFromString(QString const& name)
+{
+    return astTypes[name];
+}
+
+struct ToEndElement {
+    ToEndElement(Stream& s) : s(s) {};
+    ~ToEndElement() { while (s.readNext() != QXmlStreamReader::EndElement) {} }
+    Stream& s;
+};
+
+Ast* getSingleElement(Ast* parent, Stream& s)
+{
+    auto ok = s.readNextStartElement();
+    qDebug() << "read element:" << s.name() << "at end" << s.atEnd() << "error" << s.errorString();
+    if (!ok) {
+        return nullptr;
+    }
+
+    auto const& name = s.name();
+    auto const astType = astTypeFromString(name.toString());
+
+    ToEndElement toEnd(s);
+
+    switch (astType) {
+        case Ast::NameAstType:
+            return NodeReader<NameAst>(parent).read(s);
+        case Ast::AssignmentAstType:
+            return NodeReader<AssignmentAst>(parent).read(s);
+        case Ast::CodeAstType:
+            return NodeReader<CodeAst>(parent).read(s);
+    };
+
+    qWarning() << "Invalid AST type encountered:" << astType << "name" << name.toString();
+    return nullptr;
+}
+
+template<typename AstT>
+void listFromXml(Ast* parent, QList<AstT*>& ret, Stream& s)
+{
+    while (auto* ast = getSingleElement(parent, s)) {
+        ret.push_back(static_cast<AstT*>(ast));
+    }
+    qDebug() << "read:" << ret.size() << "list items";
+}
+
+template<typename AstT>
+void singleFromXml(Ast* parent, AstT*& ret, Stream& s)
+{
+    auto* ast = getSingleElement(parent, s);
+    ret = static_cast<AstT*>(ast);
+}
+
+CodeAst* Python::astFromXml(QString const& data)
+{
+    QXmlStreamReader s(data);
+    if (s.readNext() != QXmlStreamReader::StartDocument) {
+        return nullptr;
+    }
+    return static_cast<CodeAst*>(getSingleElement(nullptr, s));
+}
+
diff --git a/parser/astfromxml.h b/parser/astfromxml.h
new file mode 100644
index 00000000..bb5039ba
--- /dev/null
+++ b/parser/astfromxml.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include <QXmlStreamReader>
+#include <QMap>
+
+#include "ast.h"
+
+namespace Python
+{
+
+CodeAst* astFromXml(QString const& data);
+
+}
+
diff --git a/parser/tests/pyasttest.cpp b/parser/tests/pyasttest.cpp
index f7ffbf35..eb2f2656 100644
--- a/parser/tests/pyasttest.cpp
+++ b/parser/tests/pyasttest.cpp
@@ -112,6 +112,7 @@ void PyAstTest::testStatements()
 void PyAstTest::testStatements_data()
 {
     QTest::addColumn<QString>("code");
+    QTest::newRow("assign_name") << "a = b";
     QTest::newRow("assign_int") << "a = 3";
     QTest::newRow("funcdef") << "def myfun(): pass";
 #if PYTHON_VERSION >= QT_VERSION_CHECK(3, 5, 0)
-- 
GitLab


From c62c91732184b0da0d921f41035c5d2f1a2c37aa Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Mon, 14 Mar 2022 00:09:23 +0100
Subject: [PATCH 03/29] Python 3.10 support: we can parse "a = 2" again!

---
 duchain/declarationbuilder.cpp |  7 -------
 duchain/expressionvisitor.cpp  | 14 ++++++++++++++
 duchain/expressionvisitor.h    |  1 +
 parser/ast.cpp                 |  5 +++++
 parser/ast.h                   |  7 +++++++
 parser/astbuilder.cpp          |  2 +-
 parser/astdefaultvisitor.cpp   |  1 +
 parser/astdefaultvisitor.h     |  2 ++
 parser/astfromxml.cpp          | 25 +++++++++++++++++++++++++
 parser/astvisitor.cpp          |  1 +
 parser/astvisitor.h            |  1 +
 11 files changed, 58 insertions(+), 8 deletions(-)

diff --git a/duchain/declarationbuilder.cpp b/duchain/declarationbuilder.cpp
index 72dca578..027d3c06 100644
--- a/duchain/declarationbuilder.cpp
+++ b/duchain/declarationbuilder.cpp
@@ -131,13 +131,6 @@ template<typename T> T* DeclarationBuilder::visitVariableDeclaration(Ast* node,
 {
     if ( node->astType == Ast::NameAstType ) {
         NameAst* currentVariableDefinition = static_cast<NameAst*>(node);
-        // those contexts can invoke a variable declaration
-        // this prevents "bar" from being declared in something like "foo = bar"
-        // This is just a sanity check, the code should never request creation of a variable
-        // in such cases.
-        if ( currentVariableDefinition->context != ExpressionAst::Context::Store ) {
-            return nullptr;
-        }
         return visitVariableDeclaration<T>(currentVariableDefinition->identifier, previous, type, flags);
     }
     else if ( node->astType == Ast::IdentifierAstType ) {
diff --git a/duchain/expressionvisitor.cpp b/duchain/expressionvisitor.cpp
index c8782b3d..d32bdcb0 100644
--- a/duchain/expressionvisitor.cpp
+++ b/duchain/expressionvisitor.cpp
@@ -638,6 +638,20 @@ void ExpressionVisitor::visitNameConstant(NameConstantAst* node)
     }
 }
 
+void ExpressionVisitor::visitConstant(ConstantAst* node)
+{
+    DUChainReadLocker lock;
+    if (std::holds_alternative<int>(node->value)) {
+        return encounter(typeObjectForIntegralType<StructureType>("int"));
+    }
+    else if (std::holds_alternative<QString>(node->value)) {
+        return encounter(typeObjectForIntegralType<StructureType>("str"));
+    }
+    else if (std::holds_alternative<float>(node->value)) {
+        return encounter(typeObjectForIntegralType<StructureType>("float"));
+    }
+}
+
 void ExpressionVisitor::visitName(Python::NameAst* node)
 {
     CursorInRevision findNameBefore;
diff --git a/duchain/expressionvisitor.h b/duchain/expressionvisitor.h
index a3d66090..6ad085ad 100644
--- a/duchain/expressionvisitor.h
+++ b/duchain/expressionvisitor.h
@@ -69,6 +69,7 @@ public:
     void visitSetComprehension(SetComprehensionAst* node) override;
     void visitIfExpression(IfExpressionAst* node) override;
     void visitNameConstant(NameConstantAst* node) override;
+    void visitConstant(ConstantAst* node) override;
     void visitAssignmentExpression(AssignmentExpressionAst* node) override;
 
     /**
diff --git a/parser/ast.cpp b/parser/ast.cpp
index 4d47efe9..71231e9e 100644
--- a/parser/ast.cpp
+++ b/parser/ast.cpp
@@ -96,6 +96,11 @@ CompareAst::CompareAst(Ast* parent): ExpressionAst(parent, Ast::CompareAstType),
     
 }
 
+ConstantAst::ConstantAst(Ast* parent) : ExpressionAst(parent, Ast::ConstantAstType), value(QString())
+{
+
+}
+
 ComprehensionAst::ComprehensionAst(Ast* parent): Ast(parent, Ast::ComprehensionAstType), target(nullptr), iterator(nullptr)
 {
     
diff --git a/parser/ast.h b/parser/ast.h
index 5d216b69..93e3e358 100644
--- a/parser/ast.h
+++ b/parser/ast.h
@@ -85,6 +85,7 @@ public:
         AwaitAstType,
         NameAstType,
         NameConstantAstType,
+        ConstantAstType,
         CallAstType,
         AttributeAstType,
         DictionaryComprehensionAstType,
@@ -574,6 +575,12 @@ public:
     ExpressionAst* value;
 };
 
+class KDEVPYTHONPARSER_EXPORT ConstantAst : public ExpressionAst {
+public:
+    ConstantAst(Ast* parent);
+    std::variant<int, float, QString> value;
+};
+
 class KDEVPYTHONPARSER_EXPORT NumberAst : public ExpressionAst {
 public:
     NumberAst(Ast* parent);
diff --git a/parser/astbuilder.cpp b/parser/astbuilder.cpp
index fa58e658..bba57c3b 100644
--- a/parser/astbuilder.cpp
+++ b/parser/astbuilder.cpp
@@ -87,7 +87,7 @@ CodeAst::Ptr AstBuilder::parse(const QUrl& filename, QString &contents)
     <Name id="a" col_offset="0" lineno="2"/>
     </targets>
     <value>
-    <Name id="b" col_offset="4" lineno="2"/>
+    <Constant value="2" col_offset="4" lineno="2" constant_type="float"/>
     </value>
     </Assign>
     </body>
diff --git a/parser/astdefaultvisitor.cpp b/parser/astdefaultvisitor.cpp
index 9c3a12a2..4fcd4626 100644
--- a/parser/astdefaultvisitor.cpp
+++ b/parser/astdefaultvisitor.cpp
@@ -33,6 +33,7 @@ void AstDefaultVisitor::visitNumber(NumberAst* node) { Q_UNUSED(node); }
 void AstDefaultVisitor::visitString(StringAst* node) { Q_UNUSED(node); }
 void AstDefaultVisitor::visitBytes(BytesAst* node) { Q_UNUSED(node); }
 void AstDefaultVisitor::visitIdentifier(Identifier* node) { Q_UNUSED(node); }
+void AstDefaultVisitor::visitConstant(ConstantAst* node) { Q_UNUSED(node); }
 
 void AstDefaultVisitor::visitJoinedString(JoinedStringAst* node) {
 //TODO: Fix range/context/??? bugs, then re-enable this.
diff --git a/parser/astdefaultvisitor.h b/parser/astdefaultvisitor.h
index bfa626cd..69705e58 100644
--- a/parser/astdefaultvisitor.h
+++ b/parser/astdefaultvisitor.h
@@ -71,6 +71,7 @@ public:
     void visitYieldFrom(YieldFromAst* node) override;
     void visitName(NameAst* node) override;
     void visitNameConstant(NameConstantAst* node) override;
+    void visitConstant(ConstantAst* node) override;
     void visitCall(CallAst* node) override;
     void visitAttribute(AttributeAst* node) override;
     void visitSubscript(SubscriptAst* node) override;
@@ -143,6 +144,7 @@ public:
     void visitYieldFrom(YieldFromAst* node) override { AstDefaultVisitor::visitYieldFrom(node); delete node; }
     void visitName(NameAst* node) override { AstDefaultVisitor::visitName(node); delete node; }
     void visitNameConstant(NameConstantAst* node) override { AstDefaultVisitor::visitNameConstant(node); delete node; }
+    void visitConstant(ConstantAst* node) override { AstDefaultVisitor::visitConstant(node); delete node; }
     void visitCall(CallAst* node) override { AstDefaultVisitor::visitCall(node); delete node; }
     void visitAttribute(AttributeAst* node) override { AstDefaultVisitor::visitAttribute(node); delete node; }
     void visitSubscript(SubscriptAst* node) override { AstDefaultVisitor::visitSubscript(node); delete node; }
diff --git a/parser/astfromxml.cpp b/parser/astfromxml.cpp
index 787067bf..b7a7be69 100644
--- a/parser/astfromxml.cpp
+++ b/parser/astfromxml.cpp
@@ -190,9 +190,32 @@ struct NodeReader<CodeAst> : public BaseNodeReader<CodeAst>
     }
 };
 
+template<>
+struct NodeReader<ConstantAst> : public BaseNodeReader<ConstantAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Attributes = enum { value, constant_type };
+    static auto constexpr AttributeNames = {"value", "constant_type"};
+
+    void readAttribute(AttributeTag<value>, QStringRef const& value) {
+        result->value = value.toString();
+    }
+
+    void readAttribute(AttributeTag<constant_type>, QStringRef const& value) {
+        if (value == "float") {
+            result->value = std::get<QString>(result->value).toFloat();
+        }
+        else if (value == "int") {
+            result->value = std::get<QString>(result->value).toInt();
+        }
+    }
+};
+
 /////////////////////////////////////
 
 QMap<QString, Ast::AstType> astTypes = {
+    {QStringLiteral("Constant"), Ast::ConstantAstType},
     {QStringLiteral("Module"), Ast::CodeAstType},
     {QStringLiteral("Assign"), Ast::AssignmentAstType},
     {QStringLiteral("Name"), Ast::NameAstType}
@@ -229,6 +252,8 @@ Ast* getSingleElement(Ast* parent, Stream& s)
             return NodeReader<AssignmentAst>(parent).read(s);
         case Ast::CodeAstType:
             return NodeReader<CodeAst>(parent).read(s);
+        case Ast::ConstantAstType:
+            return NodeReader<ConstantAst>(parent).read(s);
     };
 
     qWarning() << "Invalid AST type encountered:" << astType << "name" << name.toString();
diff --git a/parser/astvisitor.cpp b/parser/astvisitor.cpp
index 44089516..6ab66e6b 100644
--- a/parser/astvisitor.cpp
+++ b/parser/astvisitor.cpp
@@ -68,6 +68,7 @@ void AstVisitor::visitNode(Ast* node)
         case Ast::YieldAstType:                                 this->visitYield(static_cast<YieldAst*>(node)); break;
         case Ast::NameAstType:                                  this->visitName(static_cast<NameAst*>(node)); break;
         case Ast::NameConstantAstType:                          this->visitNameConstant(static_cast<NameConstantAst*>(node)); break;
+        case Ast::ConstantAstType:                              this->visitConstant(static_cast<ConstantAst*>(node)); break;
         case Ast::CallAstType:                                  this->visitCall(static_cast<CallAst*>(node)); break;
         case Ast::AttributeAstType:                             this->visitAttribute(static_cast<AttributeAst*>(node)); break;
         case Ast::SubscriptAstType:                             this->visitSubscript(static_cast<SubscriptAst*>(node)); break;
diff --git a/parser/astvisitor.h b/parser/astvisitor.h
index bdb0da60..a3241eed 100644
--- a/parser/astvisitor.h
+++ b/parser/astvisitor.h
@@ -83,6 +83,7 @@ public:
     virtual void visitYield(YieldAst* node) { Q_UNUSED(node); };
     virtual void visitName(NameAst* node) { Q_UNUSED(node); };
     virtual void visitNameConstant(NameConstantAst* node) { Q_UNUSED(node); };
+    virtual void visitConstant(ConstantAst* node) { Q_UNUSED(node); };
     virtual void visitCall(CallAst* node) { Q_UNUSED(node); };
     virtual void visitAttribute(AttributeAst* node) { Q_UNUSED(node); };
     virtual void visitSubscript(SubscriptAst* node) { Q_UNUSED(node); };
-- 
GitLab


From 11385fdc6f327be9f146ba0707bde192e9855d26 Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Mon, 14 Mar 2022 00:23:47 +0100
Subject: [PATCH 04/29] temporary hack to get AST XML

This should be executed in-process, I think.
---
 parser/ast2xml.py     | 23 +++++++----------------
 parser/astbuilder.cpp | 43 +++++++++++++++++++++++++------------------
 2 files changed, 32 insertions(+), 34 deletions(-)

diff --git a/parser/ast2xml.py b/parser/ast2xml.py
index 93c9ce6c..32f66a12 100644
--- a/parser/ast2xml.py
+++ b/parser/ast2xml.py
@@ -4,6 +4,8 @@ import ast
 from lxml import etree
 from io import BytesIO
 
+import sys
+
 plain_types = (type(0), type(""), type(0.0), type(False), type(None))
 list_type = type([])
 
@@ -12,35 +14,24 @@ class ASTSerializer(ast.NodeVisitor):
         self.xf = xf
 
     def generic_visit(self, node):
-        print("visiting node", node)
         name = type(node).__name__
-        attrs = {k: getattr(node, k) for k in node._fields}
+        attrs = {k: getattr(node, k) for k in node._fields} if hasattr(node, "_fields") else dict()
         plain_attrs = {k: str(v) for k, v in attrs.items() if type(v) in plain_types}
         other_attrs = {k: v for k, v in attrs.items() if type(v) not in plain_types}
-        print("\tplain attrs:", plain_attrs)
-        print("\tother attrs:", other_attrs)
         with xf.element(name, **plain_attrs) as elem:
             for attrName, attrValue in other_attrs.items():
                 with xf.element(attrName):
                     if type(attrValue) == list_type:
-                        print("visiting list name", attrName)
-                        print(attrValue)
                         for node in attrValue:
                             self.generic_visit(node)
                     else:
                         self.generic_visit(attrValue)
 
 
-m = ast.parse("""
-a = 3
-b = 5
-def func(x: int, *args, **kwargs):
-    c = x
-    if 3 < 5 < 7:
-        yield
-    if c is not None:
-        return {x: v for x, v in c}
-""")
+with open(sys.argv[1], "r") as fp:
+    text = fp.read()
+
+m = ast.parse(text)
 
 f = BytesIO()
 with etree.xmlfile(f) as xf:
diff --git a/parser/astbuilder.cpp b/parser/astbuilder.cpp
index bba57c3b..26ad1736 100644
--- a/parser/astbuilder.cpp
+++ b/parser/astbuilder.cpp
@@ -21,6 +21,8 @@
 #include "astfromxml.h"
 
 #include <QDebug>
+#include <QTemporaryFile>
+#include <QProcess>
 #include "parserdebug.h"
 
 using namespace KDevelop;
@@ -53,6 +55,7 @@ QString PyUnicodeObjectToQString(PyObject* obj) {
 }
 
 namespace {
+
 struct PythonInitializer : private QMutexLocker {
     PythonInitializer(QMutex& pyInitLock):
         QMutexLocker(&pyInitLock), arena(nullptr)
@@ -72,6 +75,27 @@ struct PythonInitializer : private QMutexLocker {
     }
     PyArena* arena;
 };
+
+Python::CodeAst* __testing_AstFromString(QString const& string) {
+    QTemporaryFile f;
+    f.open();
+    f.write(string.toUtf8());
+    qDebug() << "written:" << string;
+    f.close();
+    QProcess p;
+    p.setProgram("/usr/bin/env");
+    p.setArguments({"python", "../parser/ast2xml.py", f.fileName()});
+    p.start();
+    p.waitForFinished(5000);
+    auto const xml = p.readAllStandardOutput();
+    auto const error = p.readAllStandardError();
+    if (!error.isEmpty()) {
+        qWarning() << "error running parser:" << QString::fromUtf8(error);
+    }
+    qDebug() << "using xml:" << xml;
+    return astFromXml(xml);
+}
+
 }
 
 CodeAst::Ptr AstBuilder::parse(const QUrl& filename, QString &contents)
@@ -79,25 +103,8 @@ CodeAst::Ptr AstBuilder::parse(const QUrl& filename, QString &contents)
     qCDebug(KDEV_PYTHON_PARSER) << " ====> AST     ====>     building abstract syntax tree for " << filename.path();
     
     contents.append('\n');
-    auto xml = R"(<?xml version="1.0"?>
-    <Module>
-    <body>
-    <Assign col_offset="0" lineno="2">
-    <targets>
-    <Name id="a" col_offset="0" lineno="2"/>
-    </targets>
-    <value>
-    <Constant value="2" col_offset="4" lineno="2" constant_type="float"/>
-    </value>
-    </Assign>
-    </body>
-    <type_ignores/>
-    </Module>
-    )";
-
-    qDebug() << "using xml:" << xml;
 
-    auto* ast = astFromXml(xml);
+    auto* ast = __testing_AstFromString(contents);
     ast->name = new Identifier(filename.fileName());
 
 #if 0
-- 
GitLab


From 5da9ee8920b15f56df844b5fa489276c07108423 Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Mon, 14 Mar 2022 14:51:28 +0100
Subject: [PATCH 05/29] split ast-from-xml stuff up a bit

---
 duchain/tests/pyduchaintest.cpp            |   1 +
 parser/ast2xml.py                          |  32 ++-
 parser/astfromxml.cpp                      | 237 +--------------------
 parser/astfromxml_detail/fromxml_fwd.h     |  16 ++
 parser/astfromxml_detail/nodereader.h      | 140 ++++++++++++
 parser/astfromxml_detail/nodereader_impl.h | 101 +++++++++
 parser/astfromxml_detail/typemap.h         |  70 ++++++
 parser/astfromxml_detail/typeswitch.h      | 138 ++++++++++++
 8 files changed, 495 insertions(+), 240 deletions(-)
 create mode 100644 parser/astfromxml_detail/fromxml_fwd.h
 create mode 100644 parser/astfromxml_detail/nodereader.h
 create mode 100644 parser/astfromxml_detail/nodereader_impl.h
 create mode 100644 parser/astfromxml_detail/typemap.h
 create mode 100644 parser/astfromxml_detail/typeswitch.h

diff --git a/duchain/tests/pyduchaintest.cpp b/duchain/tests/pyduchaintest.cpp
index 71f6e427..4b74cd44 100644
--- a/duchain/tests/pyduchaintest.cpp
+++ b/duchain/tests/pyduchaintest.cpp
@@ -633,6 +633,7 @@ void PyDUChainTest::testSimple_data()
     QTest::newRow("op") << "a = 3; b = a+2;" << 2 << 1;
     QTest::newRow("bool") << "a = True" << 1 << 0;
     QTest::newRow("op") << "a = True and True;" << 1 << 0;
+    QTest::newRow("fndef") << "def f(): return 0" << 1 << 0;
 }
 
 class AttributeRangeTestVisitor : public AstDefaultVisitor {
diff --git a/parser/ast2xml.py b/parser/ast2xml.py
index 32f66a12..49c76984 100644
--- a/parser/ast2xml.py
+++ b/parser/ast2xml.py
@@ -6,7 +6,7 @@ from io import BytesIO
 
 import sys
 
-plain_types = (type(0), type(""), type(0.0), type(False), type(None))
+plain_types = (type(0), type(""), type(b""), type(0.0), type(False), type(None))
 list_type = type([])
 
 class ASTSerializer(ast.NodeVisitor):
@@ -16,17 +16,29 @@ class ASTSerializer(ast.NodeVisitor):
     def generic_visit(self, node):
         name = type(node).__name__
         attrs = {k: getattr(node, k) for k in node._fields} if hasattr(node, "_fields") else dict()
+        if hasattr(node, "col_offset"):
+            attrs["col_offset"] = node.col_offset
+            attrs["lineno"] = node.lineno
+        if name == "Constant":
+            attrs["constant_type"] = type(node.value).__name__
         plain_attrs = {k: str(v) for k, v in attrs.items() if type(v) in plain_types}
-        other_attrs = {k: v for k, v in attrs.items() if type(v) not in plain_types}
+        non_plain_attrs = {k: v for k, v in attrs.items() if type(v) not in plain_types}
         with xf.element(name, **plain_attrs) as elem:
-            for attrName, attrValue in other_attrs.items():
-                with xf.element(attrName):
-                    if type(attrValue) == list_type:
-                        for node in attrValue:
-                            self.generic_visit(node)
-                    else:
-                        self.generic_visit(attrValue)
-
+            for attr, attr_val in non_plain_attrs.items():
+                if attr == "ctx":
+                    continue
+                if type(attr_val) == list_type:
+                    with xf.element(attr) as list_name_elem:
+                        for entry in attr_val:
+                            self.generic_visit(entry)
+                elif attr_val is None:
+                    pass
+                elif issubclass(type(attr_val), ast.AST) or type(attr_val).__name__ == "ellipsis":
+                    with xf.element(attr) as name_elem:
+                        self.generic_visit(attr_val)
+                else:
+                    print(attr, attr_val, type(attr_val))
+                    assert False
 
 with open(sys.argv[1], "r") as fp:
     text = fp.read()
diff --git a/parser/astfromxml.cpp b/parser/astfromxml.cpp
index b7a7be69..c2142791 100644
--- a/parser/astfromxml.cpp
+++ b/parser/astfromxml.cpp
@@ -1,225 +1,9 @@
 #include "astfromxml.h"
 
-#include <initializer_list>
-#include <type_traits>
-
-#include <QList>
-
-using namespace Python;
-
-using StringList = std::initializer_list<const char*>;
-template<int Attr> using AttributeTag = std::integral_constant<int, Attr>;
-template<int Child> using ChildTag = std::integral_constant<int, Child>;
-
-using Stream = QXmlStreamReader;
-
-enum global_attributes {col_offset = -1, lineno = -2, last_global_attribute = lineno};
-StringList global_attribute_names = {"col_offset", "lineno"};
-
-template<typename Attributes, int AttributeCount, typename Children, int ChildCount, typename Reader>
-struct NodeReadHelper {
-    constexpr NodeReadHelper(Reader* r, StringList attributeNames, StringList childNames)
-        : r(r)
-        , attributeNames(attributeNames)
-        , childNames(childNames)
-    {
-    }
-
-    template<int N>
-    void tryReadAttributes(QStringRef const& attributeName, QStringRef const& attributeValue) {
-        if constexpr (N >= 0) {
-            if (attributeName == *(r->AttributeNames.begin() + N)) {
-                r->readAttribute(AttributeTag<N>{}, attributeValue);
-                return;
-            }
-        }
-        else {
-            if (attributeName == *(global_attribute_names.begin() - (N+1))) {
-                r->readGlobalAttribute(AttributeTag<N>{}, attributeValue);
-                return;
-            }
-        }
-
-        if constexpr (N > last_global_attribute)
-            tryReadAttributes<N-1>(attributeName, attributeValue);
-        if constexpr (N == last_global_attribute)
-            qWarning() << "failed to match xml attribute name:" << attributeName;
-    }
-
-    void readAttributes(Stream& s) {
-        if constexpr (AttributeCount > 0) {
-            auto const& attributes = s.attributes();
-            for (auto const& attr: attributes) {
-                qDebug() << "read attribute:" << attr.name() << attr.value();
-                tryReadAttributes<AttributeCount - 1>(attr.name(), attr.value());
-            }
-        }
-    }
-
-    template<int N>
-    void readSingleChild(QStringRef const& childName, Stream& s) {
-        auto const nameMatches = childName == *(r->ChildNames.begin() + N);
-        qDebug() << "checking child name:" << nameMatches << childName << *(r->ChildNames.begin() + N) << N;
-        if (nameMatches) {
-            r->readChild(ChildTag<N>{}, s);
-        }
-        else {
-            if constexpr (N > 0)
-                readSingleChild<N-1>(childName, s);
-            if constexpr (N == 0)
-                qWarning() << "failed to match xml child attribute:" << childName;
-        }
-    }
-
-    void readChildren(Stream& s) {
-        if constexpr (ChildCount > 0) {
-            qDebug() << " >> starting read list";
-            while (s.readNextStartElement()) {
-                qDebug() << "read node attribute child:" << s.name();
-                readSingleChild<ChildCount - 1>(s.name(), s);
-            }
-            qDebug() << " << finished read list:" << s.name();
-        }
-    };
-
-    Reader* r;
-    const StringList attributeNames, childNames;
-};
-
-template<typename Derived>
-void doReadNode(Derived* r, Stream& s)
-{
-    using ThisReader = NodeReadHelper<
-        typename Derived::Attributes, Derived::AttributeNames.size(),
-        typename Derived::Children, Derived::ChildNames.size(),
-        Derived
-    >;
-
-    ThisReader reader(r, r->AttributeNames, r->ChildNames);
-    reader.readAttributes(s);
-    reader.readChildren(s);
-}
-
-template<typename AstT>
-struct NodeReader
-{
-};
-
-template<typename AstT>
-struct BaseNodeReader
-{
-    using Children = enum {};
-    using Attributes = enum {};
-
-    static constexpr StringList ChildNames = {};
-    static constexpr StringList AttributeNames = {};
-
-    AstT* read(Stream& s) {
-        using Derived = NodeReader<AstT>;
-        auto* derivedInstance = static_cast<Derived*>(this);
-        doReadNode<Derived>(derivedInstance, s);
-        return derivedInstance->result;
-    }
-
-    void readGlobalAttribute(AttributeTag<col_offset>, QStringRef const& value) {
-        result->startCol = value.toInt();
-    }
-
-    void readGlobalAttribute(AttributeTag<lineno>, QStringRef const& value) {
-        result->startLine = value.toInt();
-    }
-
-    AstT* result;
-
-    BaseNodeReader(Ast* parent) {
-        result = new AstT(parent);
-    }
-};
-
-
-Ast* getSinglElement(Stream& s);
-
-template<typename AstT>
-void listFromXml(Ast* parent, QList<AstT*>& ret, Stream& s);
-
-template<typename AstT>
-void singleFromXml(Ast* parent, AstT*& ret, Stream& s);
-
-/////////////////////////////////////
-
-template<>
-struct NodeReader<NameAst> : public BaseNodeReader<NameAst>
-{
-    using BaseNodeReader::BaseNodeReader;
-
-    using Attributes = enum { identifier };
-    static auto constexpr AttributeNames = {"id"};
-
-    void readAttribute(AttributeTag<identifier>, QStringRef const& value) {
-        result->identifier = new Identifier(value.toString());
-    }
-};
-
-template<>
-struct NodeReader<AssignmentAst> : public BaseNodeReader<AssignmentAst>
-{
-    using BaseNodeReader::BaseNodeReader;
-
-    using Children = enum { targets, value };
-    static auto constexpr ChildNames = {"targets", "value"};
-
-    void readChild(ChildTag<targets>, Stream& s) {
-        listFromXml(result, result->targets, s);
-    }
-
-    void readChild(ChildTag<value>, Stream& s) {
-        singleFromXml(result, result->value, s);
-    }
-};
-
-template<>
-struct NodeReader<CodeAst> : public BaseNodeReader<CodeAst>
-{
-    using BaseNodeReader::BaseNodeReader;
-
-    using Children = enum { body };
-    static auto constexpr ChildNames = {"body"};
-
-    void readChild(ChildTag<body>, Stream& s) {
-        listFromXml(result, result->body, s);
-    }
-};
-
-template<>
-struct NodeReader<ConstantAst> : public BaseNodeReader<ConstantAst>
-{
-    using BaseNodeReader::BaseNodeReader;
-
-    using Attributes = enum { value, constant_type };
-    static auto constexpr AttributeNames = {"value", "constant_type"};
-
-    void readAttribute(AttributeTag<value>, QStringRef const& value) {
-        result->value = value.toString();
-    }
-
-    void readAttribute(AttributeTag<constant_type>, QStringRef const& value) {
-        if (value == "float") {
-            result->value = std::get<QString>(result->value).toFloat();
-        }
-        else if (value == "int") {
-            result->value = std::get<QString>(result->value).toInt();
-        }
-    }
-};
-
-/////////////////////////////////////
-
-QMap<QString, Ast::AstType> astTypes = {
-    {QStringLiteral("Constant"), Ast::ConstantAstType},
-    {QStringLiteral("Module"), Ast::CodeAstType},
-    {QStringLiteral("Assign"), Ast::AssignmentAstType},
-    {QStringLiteral("Name"), Ast::NameAstType}
-};
+#include "astfromxml_detail/typemap.h"
+#include "astfromxml_detail/typeswitch.h"
+#include "astfromxml_detail/nodereader.h"
+#include "astfromxml_detail/nodereader_impl.h"
 
 Ast::AstType astTypeFromString(QString const& name)
 {
@@ -245,16 +29,9 @@ Ast* getSingleElement(Ast* parent, Stream& s)
 
     ToEndElement toEnd(s);
 
-    switch (astType) {
-        case Ast::NameAstType:
-            return NodeReader<NameAst>(parent).read(s);
-        case Ast::AssignmentAstType:
-            return NodeReader<AssignmentAst>(parent).read(s);
-        case Ast::CodeAstType:
-            return NodeReader<CodeAst>(parent).read(s);
-        case Ast::ConstantAstType:
-            return NodeReader<ConstantAst>(parent).read(s);
-    };
+    auto* ast = readTyped(parent, astType, s);
+    if (ast)
+        return ast;
 
     qWarning() << "Invalid AST type encountered:" << astType << "name" << name.toString();
     return nullptr;
diff --git a/parser/astfromxml_detail/fromxml_fwd.h b/parser/astfromxml_detail/fromxml_fwd.h
new file mode 100644
index 00000000..68ec551e
--- /dev/null
+++ b/parser/astfromxml_detail/fromxml_fwd.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include <QXmlStreamReader>
+#include "ast.h"
+
+using namespace Python;
+
+using Stream = QXmlStreamReader;
+
+Ast* getSingleElement(Stream& s);
+
+template<typename AstT>
+void listFromXml(Ast* parent, QList<AstT*>& ret, Stream& s);
+
+template<typename AstT>
+void singleFromXml(Ast* parent, AstT*& ret, Stream& s);
diff --git a/parser/astfromxml_detail/nodereader.h b/parser/astfromxml_detail/nodereader.h
new file mode 100644
index 00000000..f67eda12
--- /dev/null
+++ b/parser/astfromxml_detail/nodereader.h
@@ -0,0 +1,140 @@
+#pragma once
+
+#include <initializer_list>
+#include <type_traits>
+
+#include <QList>
+
+#include "ast.h"
+#include "fromxml_fwd.h"
+
+using namespace Python;
+
+using StringList = std::initializer_list<const char*>;
+template<int Attr> using AttributeTag = std::integral_constant<int, Attr>;
+template<int Child> using ChildTag = std::integral_constant<int, Child>;
+
+enum global_attributes {col_offset = -1, lineno = -2, last_global_attribute = lineno};
+StringList global_attribute_names = {"col_offset", "lineno"};
+
+template<typename Attributes, int AttributeCount, typename Children, int ChildCount, typename Reader>
+struct NodeReadHelper {
+    constexpr NodeReadHelper(Reader* r, StringList attributeNames, StringList childNames)
+    : r(r)
+    , attributeNames(attributeNames)
+    , childNames(childNames)
+    {
+    }
+
+    template<int N>
+    void tryReadAttributes(QStringRef const& attributeName, QStringRef const& attributeValue) {
+        if constexpr (N >= 0) {
+            if (attributeName == *(r->AttributeNames.begin() + N)) {
+                r->readAttribute(AttributeTag<N>{}, attributeValue);
+                return;
+            }
+        }
+        else {
+            if (attributeName == *(global_attribute_names.begin() - (N+1))) {
+                r->readGlobalAttribute(AttributeTag<N>{}, attributeValue);
+                return;
+            }
+        }
+
+        if constexpr (N > last_global_attribute)
+            tryReadAttributes<N-1>(attributeName, attributeValue);
+        if constexpr (N == last_global_attribute)
+            qWarning() << "failed to match xml attribute name:" << attributeName;
+    }
+
+    void readAttributes(Stream& s) {
+        if constexpr (AttributeCount > 0) {
+            auto const& attributes = s.attributes();
+            for (auto const& attr: attributes) {
+                qDebug() << "read attribute:" << attr.name() << attr.value();
+                tryReadAttributes<AttributeCount - 1>(attr.name(), attr.value());
+            }
+        }
+    }
+
+    template<int N>
+    void readSingleChild(QStringRef const& childName, Stream& s) {
+        auto const nameMatches = childName == *(r->ChildNames.begin() + N);
+        qDebug() << "checking child name:" << nameMatches << childName << *(r->ChildNames.begin() + N) << N;
+        if (nameMatches) {
+            r->readChild(ChildTag<N>{}, s);
+        }
+        else {
+            if constexpr (N > 0)
+                readSingleChild<N-1>(childName, s);
+            if constexpr (N == 0)
+                qWarning() << "failed to match xml child attribute:" << childName;
+        }
+    }
+
+    void readChildren(Stream& s) {
+        if constexpr (ChildCount > 0) {
+            qDebug() << " >> starting read list";
+            while (s.readNextStartElement()) {
+                qDebug() << "read node attribute child:" << s.name();
+                readSingleChild<ChildCount - 1>(s.name(), s);
+            }
+            qDebug() << " << finished read list:" << s.name();
+        }
+    };
+
+    Reader* r;
+    const StringList attributeNames, childNames;
+};
+
+template<typename Derived>
+void doReadNode(Derived* r, Stream& s)
+{
+    using ThisReader = NodeReadHelper<
+    typename Derived::Attributes, Derived::AttributeNames.size(),
+    typename Derived::Children, Derived::ChildNames.size(),
+    Derived
+    >;
+
+    ThisReader reader(r, r->AttributeNames, r->ChildNames);
+    reader.readAttributes(s);
+    reader.readChildren(s);
+}
+
+template<typename AstT>
+struct NodeReader
+{
+    NodeReader(Ast*) {}
+    Ast* read(Stream&) { return nullptr; }
+};
+
+template<typename AstT>
+struct BaseNodeReader
+{
+    using Children = enum {};
+    using Attributes = enum {};
+
+    static constexpr StringList ChildNames = {};
+    static constexpr StringList AttributeNames = {};
+
+    AstT* read(Stream& s) {
+        using Derived = NodeReader<AstT>;
+        auto* derivedInstance = static_cast<Derived*>(this);
+        doReadNode<Derived>(derivedInstance, s);
+        return derivedInstance->result;
+    }
+
+    void readGlobalAttribute(AttributeTag<col_offset>, QStringRef const& value) {
+        result->startCol = value.toInt();
+    }
+
+    void readGlobalAttribute(AttributeTag<lineno>, QStringRef const& value) {
+        result->startLine = value.toInt() - 1;
+    }
+
+    AstT* result;
+
+    BaseNodeReader(Ast* parent) {
+        result = new AstT(parent);
+    }
+};
diff --git a/parser/astfromxml_detail/nodereader_impl.h b/parser/astfromxml_detail/nodereader_impl.h
new file mode 100644
index 00000000..cd1441a3
--- /dev/null
+++ b/parser/astfromxml_detail/nodereader_impl.h
@@ -0,0 +1,101 @@
+#pragma once
+
+#include "nodereader.h"
+#include "fromxml_fwd.h"
+
+template<>
+struct NodeReader<FunctionDefinitionAst> : public BaseNodeReader<FunctionDefinitionAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Attributes = enum { name };
+    static auto constexpr AttributeNames = {"name"};
+
+    using Children = enum { arguments, decorators, body, returns };
+    static auto constexpr ChildNames = {"arguments", "decorators", "body", "returns"};
+
+    void readAttribute(AttributeTag<name>, QStringRef const& value) {
+        result->name = new Identifier(value.toString());
+    }
+
+    void readChild(ChildTag<arguments>, Stream& s) {
+        singleFromXml(result, result->arguments, s);
+    }
+
+    void readChild(ChildTag<decorators>, Stream& s) {
+        listFromXml(result, result->decorators, s);
+    }
+
+    void readChild(ChildTag<body>, Stream& s) {
+        listFromXml(result, result->body, s);
+    }
+
+    void readChild(ChildTag<returns>, Stream& s) {
+        singleFromXml(result, result->returns, s);
+    }
+};
+
+template<>
+struct NodeReader<NameAst> : public BaseNodeReader<NameAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Attributes = enum { identifier };
+    static auto constexpr AttributeNames = {"id"};
+
+    void readAttribute(AttributeTag<identifier>, QStringRef const& value) {
+        result->identifier = new Identifier(value.toString());
+    }
+};
+
+template<>
+struct NodeReader<AssignmentAst> : public BaseNodeReader<AssignmentAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { targets, value };
+    static auto constexpr ChildNames = {"targets", "value"};
+
+    void readChild(ChildTag<targets>, Stream& s) {
+        listFromXml(result, result->targets, s);
+    }
+
+    void readChild(ChildTag<value>, Stream& s) {
+        singleFromXml(result, result->value, s);
+    }
+};
+
+template<>
+struct NodeReader<CodeAst> : public BaseNodeReader<CodeAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { body };
+    static auto constexpr ChildNames = {"body"};
+
+    void readChild(ChildTag<body>, Stream& s) {
+        listFromXml(result, result->body, s);
+    }
+};
+
+template<>
+struct NodeReader<ConstantAst> : public BaseNodeReader<ConstantAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Attributes = enum { value, constant_type };
+    static auto constexpr AttributeNames = {"value", "constant_type"};
+
+    void readAttribute(AttributeTag<value>, QStringRef const& value) {
+        result->value = value.toString();
+    }
+
+    void readAttribute(AttributeTag<constant_type>, QStringRef const& value) {
+        if (value == "float") {
+            result->value = std::get<QString>(result->value).toFloat();
+        }
+        else if (value == "int") {
+            result->value = std::get<QString>(result->value).toInt();
+        }
+    }
+};
diff --git a/parser/astfromxml_detail/typemap.h b/parser/astfromxml_detail/typemap.h
new file mode 100644
index 00000000..1b5c5a57
--- /dev/null
+++ b/parser/astfromxml_detail/typemap.h
@@ -0,0 +1,70 @@
+#pragma once
+
+#include "ast.h"
+
+using namespace Python;
+
+QMap<QString, Ast::AstType> astTypes = {
+    {QStringLiteral("AsyncFunctionDef"), Ast::FunctionDefinitionAstType},
+    {QStringLiteral("FunctionDef"), Ast::FunctionDefinitionAstType},
+    {QStringLiteral("Assignment"), Ast::AssignmentAstType},
+    {QStringLiteral("Pass"), Ast::PassAstType},
+    {QStringLiteral("Nonlocal"), Ast::NonlocalAstType},
+    {QStringLiteral("arguments"), Ast::ArgumentsAstType},
+    {QStringLiteral("arg"), Ast::ArgAstType},
+    {QStringLiteral("Keyword"), Ast::KeywordAstType},
+    {QStringLiteral("ClassDefinition"), Ast::ClassDefinitionAstType},
+    {QStringLiteral("Return"), Ast::ReturnAstType},
+    {QStringLiteral("Delete"), Ast::DeleteAstType},
+    {QStringLiteral("For"), Ast::ForAstType},
+    {QStringLiteral("While"), Ast::WhileAstType},
+    {QStringLiteral("If"), Ast::IfAstType},
+    {QStringLiteral("With"), Ast::WithAstType},
+    {QStringLiteral("WithItem"), Ast::WithItemAstType},
+    {QStringLiteral("Raise"), Ast::RaiseAstType},
+    {QStringLiteral("Try"), Ast::TryAstType},
+    {QStringLiteral("Import"), Ast::ImportAstType},
+    {QStringLiteral("ImportFrom"), Ast::ImportFromAstType},
+    {QStringLiteral("Global"), Ast::GlobalAstType},
+    {QStringLiteral("Break"), Ast::BreakAstType},
+    {QStringLiteral("Continue"), Ast::ContinueAstType},
+    {QStringLiteral("Assertion"), Ast::AssertionAstType},
+    {QStringLiteral("AugmentedAssignment"), Ast::AugmentedAssignmentAstType},
+    {QStringLiteral("AnnotationAssignment"), Ast::AnnotationAssignmentAstType},
+    {QStringLiteral("Await"), Ast::AwaitAstType},
+    {QStringLiteral("Name"), Ast::NameAstType},
+    {QStringLiteral("NameConstant"), Ast::NameConstantAstType},
+    {QStringLiteral("Constant"), Ast::ConstantAstType},
+    {QStringLiteral("Call"), Ast::CallAstType},
+    {QStringLiteral("Attribute"), Ast::AttributeAstType},
+    {QStringLiteral("DictionaryComprehension"), Ast::DictionaryComprehensionAstType},
+    {QStringLiteral("BooleanOperation"), Ast::BooleanOperationAstType},
+    {QStringLiteral("BinaryOperation"), Ast::BinaryOperationAstType},
+    {QStringLiteral("UnaryOperation"), Ast::UnaryOperationAstType},
+    {QStringLiteral("Lambda"), Ast::LambdaAstType},
+    {QStringLiteral("IfExpression"), Ast::IfExpressionAstType},
+    {QStringLiteral("Dict"), Ast::DictAstType},
+    {QStringLiteral("Set"), Ast::SetAstType},
+    {QStringLiteral("ListComprehension"), Ast::ListComprehensionAstType},
+    {QStringLiteral("SetComprehension"), Ast::SetComprehensionAstType},
+    {QStringLiteral("GeneratorExpression"), Ast::GeneratorExpressionAstType},
+    {QStringLiteral("Yield"), Ast::YieldAstType},
+    {QStringLiteral("Compare"), Ast::CompareAstType},
+    {QStringLiteral("Number"), Ast::NumberAstType},
+    {QStringLiteral("String"), Ast::StringAstType},
+    {QStringLiteral("JoinedString"), Ast::JoinedStringAstType},
+    {QStringLiteral("FormattedValue"), Ast::FormattedValueAstType},
+    {QStringLiteral("Bytes"), Ast::BytesAstType},
+    {QStringLiteral("Subscript"), Ast::SubscriptAstType},
+    {QStringLiteral("Starred"), Ast::StarredAstType},
+    {QStringLiteral("List"), Ast::ListAstType},
+    {QStringLiteral("Tuple"), Ast::TupleAstType},
+    {QStringLiteral("YieldFrom"), Ast::YieldFromAstType},
+    {QStringLiteral("Comprehension"), Ast::ComprehensionAstType},
+    {QStringLiteral("Slice"), Ast::SliceAstType},
+    {QStringLiteral("Ellipsis"), Ast::EllipsisAstType},
+    {QStringLiteral("AssignmentExpression"), Ast::AssignmentExpressionAstType},
+    {QStringLiteral("Module"), Ast::CodeAstType},
+    {QStringLiteral("ExceptionHandler"), Ast::ExceptionHandlerAstType},
+    {QStringLiteral("Alias"), Ast::AliasAstType},
+};
diff --git a/parser/astfromxml_detail/typeswitch.h b/parser/astfromxml_detail/typeswitch.h
new file mode 100644
index 00000000..a58ff675
--- /dev/null
+++ b/parser/astfromxml_detail/typeswitch.h
@@ -0,0 +1,138 @@
+#pragma once
+#include "fromxml_fwd.h"
+#include "nodereader.h"
+#include "nodereader_impl.h"
+
+Ast* readTyped(Ast* parent, Python::Ast::AstType astType, Stream& s) {
+    switch (astType) {
+        case Ast::FunctionDefinitionAstType:
+            return NodeReader<FunctionDefinitionAst>(parent).read(s);
+        case Ast::AssignmentAstType:
+            return NodeReader<AssignmentAst>(parent).read(s);
+        case Ast::PassAstType:
+            return NodeReader<PassAst>(parent).read(s);
+        case Ast::NonlocalAstType:
+            return NodeReader<NonlocalAst>(parent).read(s);
+        case Ast::ArgumentsAstType:
+            return NodeReader<ArgumentsAst>(parent).read(s);
+        case Ast::ArgAstType:
+            return NodeReader<ArgAst>(parent).read(s);
+        case Ast::KeywordAstType:
+            return NodeReader<KeywordAst>(parent).read(s);
+        case Ast::ClassDefinitionAstType:
+            return NodeReader<ClassDefinitionAst>(parent).read(s);
+        case Ast::ReturnAstType:
+            return NodeReader<ReturnAst>(parent).read(s);
+        case Ast::DeleteAstType:
+            return NodeReader<DeleteAst>(parent).read(s);
+        case Ast::ForAstType:
+            return NodeReader<ForAst>(parent).read(s);
+        case Ast::WhileAstType:
+            return NodeReader<WhileAst>(parent).read(s);
+        case Ast::IfAstType:
+            return NodeReader<IfAst>(parent).read(s);
+        case Ast::WithAstType:
+            return NodeReader<WithAst>(parent).read(s);
+        case Ast::WithItemAstType:
+            return NodeReader<WithItemAst>(parent).read(s);
+        case Ast::RaiseAstType:
+            return NodeReader<RaiseAst>(parent).read(s);
+        case Ast::TryAstType:
+            return NodeReader<TryAst>(parent).read(s);
+        case Ast::ImportAstType:
+            return NodeReader<ImportAst>(parent).read(s);
+        case Ast::ImportFromAstType:
+            return NodeReader<ImportFromAst>(parent).read(s);
+        case Ast::GlobalAstType:
+            return NodeReader<GlobalAst>(parent).read(s);
+        case Ast::BreakAstType:
+            return NodeReader<BreakAst>(parent).read(s);
+        case Ast::ContinueAstType:
+            return NodeReader<ContinueAst>(parent).read(s);
+        case Ast::AssertionAstType:
+            return NodeReader<AssertionAst>(parent).read(s);
+        case Ast::AugmentedAssignmentAstType:
+            return NodeReader<AugmentedAssignmentAst>(parent).read(s);
+        case Ast::AnnotationAssignmentAstType:
+            return NodeReader<AnnotationAssignmentAst>(parent).read(s);
+        case Ast::AwaitAstType:
+            return NodeReader<AwaitAst>(parent).read(s);
+        case Ast::NameAstType:
+            return NodeReader<NameAst>(parent).read(s);
+        case Ast::NameConstantAstType:
+            return NodeReader<NameConstantAst>(parent).read(s);
+        case Ast::ConstantAstType:
+            return NodeReader<ConstantAst>(parent).read(s);
+        case Ast::CallAstType:
+            return NodeReader<CallAst>(parent).read(s);
+        case Ast::AttributeAstType:
+            return NodeReader<AttributeAst>(parent).read(s);
+        case Ast::DictionaryComprehensionAstType:
+            return NodeReader<DictionaryComprehensionAst>(parent).read(s);
+        case Ast::BooleanOperationAstType:
+            return NodeReader<BooleanOperationAst>(parent).read(s);
+        case Ast::BinaryOperationAstType:
+            return NodeReader<BinaryOperationAst>(parent).read(s);
+        case Ast::UnaryOperationAstType:
+            return NodeReader<UnaryOperationAst>(parent).read(s);
+        case Ast::LambdaAstType:
+            return NodeReader<LambdaAst>(parent).read(s);
+        case Ast::IfExpressionAstType:
+            return NodeReader<IfExpressionAst>(parent).read(s);
+        case Ast::DictAstType:
+            return NodeReader<DictAst>(parent).read(s);
+        case Ast::SetAstType:
+            return NodeReader<SetAst>(parent).read(s);
+        case Ast::ListComprehensionAstType:
+            return NodeReader<ListComprehensionAst>(parent).read(s);
+        case Ast::SetComprehensionAstType:
+            return NodeReader<SetComprehensionAst>(parent).read(s);
+        case Ast::GeneratorExpressionAstType:
+            return NodeReader<GeneratorExpressionAst>(parent).read(s);
+        case Ast::YieldAstType:
+            return NodeReader<YieldAst>(parent).read(s);
+        case Ast::CompareAstType:
+            return NodeReader<CompareAst>(parent).read(s);
+        case Ast::NumberAstType:
+            return NodeReader<NumberAst>(parent).read(s);
+        case Ast::StringAstType:
+            return NodeReader<StringAst>(parent).read(s);
+        case Ast::JoinedStringAstType:
+            return NodeReader<JoinedStringAst>(parent).read(s);
+        case Ast::FormattedValueAstType:
+            return NodeReader<FormattedValueAst>(parent).read(s);
+        case Ast::BytesAstType:
+            return NodeReader<BytesAst>(parent).read(s);
+        case Ast::SubscriptAstType:
+            return NodeReader<SubscriptAst>(parent).read(s);
+        case Ast::StarredAstType:
+            return NodeReader<StarredAst>(parent).read(s);
+        case Ast::ListAstType:
+            return NodeReader<ListAst>(parent).read(s);
+        case Ast::TupleAstType:
+            return NodeReader<TupleAst>(parent).read(s);
+        case Ast::YieldFromAstType:
+            return NodeReader<YieldFromAst>(parent).read(s);
+        case Ast::ComprehensionAstType:
+            return NodeReader<ComprehensionAst>(parent).read(s);
+        case Ast::SliceAstType:
+            return NodeReader<SliceAst>(parent).read(s);
+        case Ast::EllipsisAstType:
+            return NodeReader<EllipsisAst>(parent).read(s);
+        case Ast::AssignmentExpressionAstType:
+            return NodeReader<AssignmentExpressionAst>(parent).read(s);
+        case Ast::CodeAstType:
+            return NodeReader<CodeAst>(parent).read(s);
+        case Ast::ExceptionHandlerAstType:
+            return NodeReader<ExceptionHandlerAst>(parent).read(s);
+        case Ast::AliasAstType:
+            return NodeReader<AliasAst>(parent).read(s);
+        case Ast::LastStatementType:
+        case Ast::ExpressionAstType:
+        case Ast::LastExpressionType:
+        case Ast::IdentifierAstType:
+        case Ast::LastAstType:
+            break;
+    };
+    return nullptr;
+}
-- 
GitLab


From d272f27956bf9e388c74633ca7916bdf4c1abc81 Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Mon, 14 Mar 2022 18:01:12 +0100
Subject: [PATCH 06/29] we can parse a function definition

---
 duchain/tests/pyduchaintest.cpp            |  2 +-
 parser/ast.cpp                             |  6 +-
 parser/ast.h                               |  7 ++
 parser/ast2xml.py                          |  1 +
 parser/astdefaultvisitor.cpp               |  1 +
 parser/astfromxml.cpp                      |  2 +-
 parser/astfromxml_detail/nodereader_impl.h | 76 +++++++++++++++-------
 parser/astfromxml_detail/typeswitch.h      |  1 +
 8 files changed, 67 insertions(+), 29 deletions(-)

diff --git a/duchain/tests/pyduchaintest.cpp b/duchain/tests/pyduchaintest.cpp
index 4b74cd44..35cc206a 100644
--- a/duchain/tests/pyduchaintest.cpp
+++ b/duchain/tests/pyduchaintest.cpp
@@ -632,7 +632,7 @@ void PyDUChainTest::testSimple_data()
     QTest::newRow("assign_str") << "b = 'hola';" << 1 << 0;
     QTest::newRow("op") << "a = 3; b = a+2;" << 2 << 1;
     QTest::newRow("bool") << "a = True" << 1 << 0;
-    QTest::newRow("op") << "a = True and True;" << 1 << 0;
+    QTest::newRow("op2") << "a = True and True;" << 1 << 0;
     QTest::newRow("fndef") << "def f(): return 0" << 1 << 0;
 }
 
diff --git a/parser/ast.cpp b/parser/ast.cpp
index 71231e9e..4581fe40 100644
--- a/parser/ast.cpp
+++ b/parser/ast.cpp
@@ -20,7 +20,7 @@ namespace Python
 Ast::Ast( Ast* parent, Ast::AstType type ) : parent(parent), astType( type ), startCol(0), startLine(-99999), endCol(0), endLine(0), hasUsefulRangeInformation(false), context(nullptr) { }
 Ast::Ast() :  parent(nullptr), startCol(0), startLine(-5), endCol(0), endLine(0), hasUsefulRangeInformation(false), context(nullptr) { }
 
-ArgumentsAst::ArgumentsAst(Ast* parent): Ast(parent, Ast::ArgumentsAstType)
+ArgumentsAst::ArgumentsAst(Ast* parent): Ast(parent, Ast::ArgumentsAstType), vararg(nullptr), kwarg(nullptr)
 {
     
 }
@@ -166,7 +166,7 @@ ForAst::ForAst(Ast* parent): StatementAst(parent, Ast::ForAstType), target(nullp
     
 }
 
-FunctionDefinitionAst::FunctionDefinitionAst(Ast* parent): StatementAst(parent, Ast::FunctionDefinitionAstType), name(nullptr), arguments(nullptr), async(false)
+FunctionDefinitionAst::FunctionDefinitionAst(Ast* parent): StatementAst(parent, Ast::FunctionDefinitionAstType), name(nullptr), arguments(nullptr), returns(nullptr), async(false)
 {
     
 }
@@ -183,7 +183,7 @@ GlobalAst::GlobalAst(Ast* parent): StatementAst(parent, Ast::GlobalAstType)
 
 Identifier::Identifier(QString value) : Ast(nullptr, Ast::IdentifierAstType), value(value)
 {
-    
+
 }
 
 IfAst::IfAst(Ast* parent): StatementAst(parent, Ast::IfAstType), condition(nullptr)
diff --git a/parser/ast.h b/parser/ast.h
index 93e3e358..f5d4c3f6 100644
--- a/parser/ast.h
+++ b/parser/ast.h
@@ -227,6 +227,7 @@ public:
 class KDEVPYTHONPARSER_EXPORT Identifier : public Ast {
 public:
     Identifier(QString value);
+    Identifier(QString value, Ast* rangeNode);
     bool operator==(const Identifier& rhs) const {
         return value == rhs.value;
     };
@@ -239,6 +240,10 @@ public:
     operator QString() const {
         return value;
     };
+    void rangeFrom(Ast* other) {
+        copyRange(other);
+        setEndColumn();
+    }
     QString value;
 };
 
@@ -251,6 +256,7 @@ public:
     typedef QSharedPointer<CodeAst> Ptr;
     QList<Ast*> body;
     Identifier* name; // module name
+    QList<Ast*> type_ignores;
 };
 
 /** Statement classes **/
@@ -715,6 +721,7 @@ public:
     QList<ArgAst*> arguments;
     QList<ArgAst*> kwonlyargs;
     QList<ArgAst*> posonlyargs;
+    QList<ExpressionAst*> kw_defaults;
     QList<ExpressionAst*> defaultValues;
     ArgAst* vararg;
     ArgAst* kwarg;
diff --git a/parser/ast2xml.py b/parser/ast2xml.py
index 49c76984..aaf063db 100644
--- a/parser/ast2xml.py
+++ b/parser/ast2xml.py
@@ -44,6 +44,7 @@ with open(sys.argv[1], "r") as fp:
     text = fp.read()
 
 m = ast.parse(text)
+m = ast.fix_missing_locations(m)
 
 f = BytesIO()
 with etree.xmlfile(f) as xf:
diff --git a/parser/astdefaultvisitor.cpp b/parser/astdefaultvisitor.cpp
index 4fcd4626..baf7557b 100644
--- a/parser/astdefaultvisitor.cpp
+++ b/parser/astdefaultvisitor.cpp
@@ -345,6 +345,7 @@ void AstDefaultVisitor::visitArguments(ArgumentsAst* node)
 {
     visitNodeList(node->arguments);
     visitNodeList(node->defaultValues);
+    visitNodeList(node->kw_defaults);
 }
 
 }
diff --git a/parser/astfromxml.cpp b/parser/astfromxml.cpp
index c2142791..777e1b8e 100644
--- a/parser/astfromxml.cpp
+++ b/parser/astfromxml.cpp
@@ -12,7 +12,7 @@ Ast::AstType astTypeFromString(QString const& name)
 
 struct ToEndElement {
     ToEndElement(Stream& s) : s(s) {};
-    ~ToEndElement() { while (s.readNext() != QXmlStreamReader::EndElement) {} }
+    ~ToEndElement() { while (!s.atEnd() && s.readNext() != QXmlStreamReader::EndElement) {} }
     Stream& s;
 };
 
diff --git a/parser/astfromxml_detail/nodereader_impl.h b/parser/astfromxml_detail/nodereader_impl.h
index cd1441a3..8340e55c 100644
--- a/parser/astfromxml_detail/nodereader_impl.h
+++ b/parser/astfromxml_detail/nodereader_impl.h
@@ -3,6 +3,11 @@
 #include "nodereader.h"
 #include "fromxml_fwd.h"
 
+#define READ_CHILD_IMPL(name) \
+    void readChild(ChildTag<name>, Stream& s) { singleFromXml(result, result->name, s); }
+#define READ_CHILD_LIST_IMPL(name) \
+    void readChild(ChildTag<name>, Stream& s) { listFromXml(result, result->name, s); }
+
 template<>
 struct NodeReader<FunctionDefinitionAst> : public BaseNodeReader<FunctionDefinitionAst>
 {
@@ -12,27 +17,52 @@ struct NodeReader<FunctionDefinitionAst> : public BaseNodeReader<FunctionDefinit
     static auto constexpr AttributeNames = {"name"};
 
     using Children = enum { arguments, decorators, body, returns };
-    static auto constexpr ChildNames = {"arguments", "decorators", "body", "returns"};
+    static auto constexpr ChildNames = {"args", "decorator_list", "body", "returns"};
 
     void readAttribute(AttributeTag<name>, QStringRef const& value) {
         result->name = new Identifier(value.toString());
     }
 
-    void readChild(ChildTag<arguments>, Stream& s) {
-        singleFromXml(result, result->arguments, s);
-    }
+    READ_CHILD_IMPL(arguments)
+    READ_CHILD_IMPL(returns)
+    READ_CHILD_LIST_IMPL(body)
+    READ_CHILD_LIST_IMPL(decorators)
 
-    void readChild(ChildTag<decorators>, Stream& s) {
-        listFromXml(result, result->decorators, s);
+    ~NodeReader() {
+        result->name->rangeFrom(result);
     }
+};
 
-    void readChild(ChildTag<body>, Stream& s) {
-        listFromXml(result, result->body, s);
-    }
+template<>
+struct NodeReader<ArgumentsAst> : public BaseNodeReader<ArgumentsAst>
+{
+    using BaseNodeReader::BaseNodeReader;
 
-    void readChild(ChildTag<returns>, Stream& s) {
-        singleFromXml(result, result->returns, s);
-    }
+    using Children = enum {
+        arguments, kwonlyargs, posonlyargs, defaultValues, vararg, kwarg, kw_defaults
+    };
+    static auto constexpr ChildNames = {
+        "args", "kwonlyargs", "posonlyargs", "defaults", "vararg", "kwarg", "kw_defaults"
+    };
+
+    READ_CHILD_LIST_IMPL(arguments)
+    READ_CHILD_LIST_IMPL(kwonlyargs)
+    READ_CHILD_LIST_IMPL(posonlyargs)
+    READ_CHILD_LIST_IMPL(defaultValues)
+    READ_CHILD_LIST_IMPL(kw_defaults)
+    READ_CHILD_IMPL(vararg)
+    READ_CHILD_IMPL(kwarg)
+};
+
+template<>
+struct NodeReader<ReturnAst> : public BaseNodeReader<ReturnAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { value };
+    static auto constexpr ChildNames = {"value"};
+
+    READ_CHILD_IMPL(value);
 };
 
 template<>
@@ -46,6 +76,10 @@ struct NodeReader<NameAst> : public BaseNodeReader<NameAst>
     void readAttribute(AttributeTag<identifier>, QStringRef const& value) {
         result->identifier = new Identifier(value.toString());
     }
+
+    ~NodeReader() {
+        result->identifier->rangeFrom(result);
+    }
 };
 
 template<>
@@ -56,13 +90,8 @@ struct NodeReader<AssignmentAst> : public BaseNodeReader<AssignmentAst>
     using Children = enum { targets, value };
     static auto constexpr ChildNames = {"targets", "value"};
 
-    void readChild(ChildTag<targets>, Stream& s) {
-        listFromXml(result, result->targets, s);
-    }
-
-    void readChild(ChildTag<value>, Stream& s) {
-        singleFromXml(result, result->value, s);
-    }
+    READ_CHILD_LIST_IMPL(targets)
+    READ_CHILD_IMPL(value)
 };
 
 template<>
@@ -70,12 +99,11 @@ struct NodeReader<CodeAst> : public BaseNodeReader<CodeAst>
 {
     using BaseNodeReader::BaseNodeReader;
 
-    using Children = enum { body };
-    static auto constexpr ChildNames = {"body"};
+    using Children = enum { body, type_ignores };
+    static auto constexpr ChildNames = {"body", "type_ignores"};
 
-    void readChild(ChildTag<body>, Stream& s) {
-        listFromXml(result, result->body, s);
-    }
+    READ_CHILD_LIST_IMPL(body)
+    READ_CHILD_LIST_IMPL(type_ignores)
 };
 
 template<>
diff --git a/parser/astfromxml_detail/typeswitch.h b/parser/astfromxml_detail/typeswitch.h
index a58ff675..8a04257c 100644
--- a/parser/astfromxml_detail/typeswitch.h
+++ b/parser/astfromxml_detail/typeswitch.h
@@ -128,6 +128,7 @@ Ast* readTyped(Ast* parent, Python::Ast::AstType astType, Stream& s) {
         case Ast::AliasAstType:
             return NodeReader<AliasAst>(parent).read(s);
         case Ast::LastStatementType:
+        case Ast::StatementAstType:
         case Ast::ExpressionAstType:
         case Ast::LastExpressionType:
         case Ast::IdentifierAstType:
-- 
GitLab


From 49e7c15e289b192557e71467737426cc36a3a21d Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Mon, 14 Mar 2022 18:35:28 +0100
Subject: [PATCH 07/29] implement binop, duchaintest test_simple passes again

---
 parser/ast2xml.py                          |  2 ++
 parser/astfromxml_detail/nodereader_impl.h | 20 +++++++++++++++++++
 parser/astfromxml_detail/operators.h       | 23 ++++++++++++++++++++++
 parser/astfromxml_detail/typemap.h         |  4 ++--
 4 files changed, 47 insertions(+), 2 deletions(-)
 create mode 100644 parser/astfromxml_detail/operators.h

diff --git a/parser/ast2xml.py b/parser/ast2xml.py
index aaf063db..d66009e0 100644
--- a/parser/ast2xml.py
+++ b/parser/ast2xml.py
@@ -21,6 +21,8 @@ class ASTSerializer(ast.NodeVisitor):
             attrs["lineno"] = node.lineno
         if name == "Constant":
             attrs["constant_type"] = type(node.value).__name__
+        if name == "BinOp":
+            attrs["op"] = type(node.op).__name__
         plain_attrs = {k: str(v) for k, v in attrs.items() if type(v) in plain_types}
         non_plain_attrs = {k: v for k, v in attrs.items() if type(v) not in plain_types}
         with xf.element(name, **plain_attrs) as elem:
diff --git a/parser/astfromxml_detail/nodereader_impl.h b/parser/astfromxml_detail/nodereader_impl.h
index 8340e55c..4260473e 100644
--- a/parser/astfromxml_detail/nodereader_impl.h
+++ b/parser/astfromxml_detail/nodereader_impl.h
@@ -2,6 +2,7 @@
 
 #include "nodereader.h"
 #include "fromxml_fwd.h"
+#include "operators.h"
 
 #define READ_CHILD_IMPL(name) \
     void readChild(ChildTag<name>, Stream& s) { singleFromXml(result, result->name, s); }
@@ -106,6 +107,25 @@ struct NodeReader<CodeAst> : public BaseNodeReader<CodeAst>
     READ_CHILD_LIST_IMPL(type_ignores)
 };
 
+template<>
+struct NodeReader<BinaryOperationAst> : public BaseNodeReader<BinaryOperationAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { lhs, rhs };
+    static auto constexpr ChildNames = {"left", "right"};
+
+    using Attributes = enum { op };
+    static auto constexpr AttributeNames = {"op"};
+
+    READ_CHILD_IMPL(lhs)
+    READ_CHILD_IMPL(rhs)
+
+    void readAttribute(AttributeTag<op>, QStringRef const& value) {
+        result->type = operatorType(value);
+    }
+};
+
 template<>
 struct NodeReader<ConstantAst> : public BaseNodeReader<ConstantAst>
 {
diff --git a/parser/astfromxml_detail/operators.h b/parser/astfromxml_detail/operators.h
new file mode 100644
index 00000000..8a8569b1
--- /dev/null
+++ b/parser/astfromxml_detail/operators.h
@@ -0,0 +1,23 @@
+#pragma once
+
+#include "ast.h"
+
+using namespace Python;
+
+Ast::OperatorTypes operatorType(QStringRef const& name) {
+    if (name == "Add") return Ast::OperatorAdd;
+    if (name == "Sub") return Ast::OperatorSub;
+    if (name == "Mult") return Ast::OperatorMult;
+    if (name == "MatMult") return Ast::OperatorMatMult;
+    if (name == "Div") return Ast::OperatorDiv;
+    if (name == "Mod") return Ast::OperatorMod;
+    if (name == "Pow") return Ast::OperatorPow;
+    if (name == "LeftShift") return Ast::OperatorLeftShift;
+    if (name == "RightShift") return Ast::OperatorRightShift;
+    if (name == "BitwiseOr") return Ast::OperatorBitwiseOr;
+    if (name == "BitwiseXor") return Ast::OperatorBitwiseXor;
+    if (name == "BitwiseAnd") return Ast::OperatorBitwiseAnd;
+    if (name == "FloorDivision") return Ast::OperatorFloorDivision;
+
+    return Ast::OperatorInvalid;
+}
diff --git a/parser/astfromxml_detail/typemap.h b/parser/astfromxml_detail/typemap.h
index 1b5c5a57..88d46094 100644
--- a/parser/astfromxml_detail/typemap.h
+++ b/parser/astfromxml_detail/typemap.h
@@ -7,7 +7,7 @@ using namespace Python;
 QMap<QString, Ast::AstType> astTypes = {
     {QStringLiteral("AsyncFunctionDef"), Ast::FunctionDefinitionAstType},
     {QStringLiteral("FunctionDef"), Ast::FunctionDefinitionAstType},
-    {QStringLiteral("Assignment"), Ast::AssignmentAstType},
+    {QStringLiteral("Assign"), Ast::AssignmentAstType},
     {QStringLiteral("Pass"), Ast::PassAstType},
     {QStringLiteral("Nonlocal"), Ast::NonlocalAstType},
     {QStringLiteral("arguments"), Ast::ArgumentsAstType},
@@ -39,7 +39,7 @@ QMap<QString, Ast::AstType> astTypes = {
     {QStringLiteral("Attribute"), Ast::AttributeAstType},
     {QStringLiteral("DictionaryComprehension"), Ast::DictionaryComprehensionAstType},
     {QStringLiteral("BooleanOperation"), Ast::BooleanOperationAstType},
-    {QStringLiteral("BinaryOperation"), Ast::BinaryOperationAstType},
+    {QStringLiteral("BinOp"), Ast::BinaryOperationAstType},
     {QStringLiteral("UnaryOperation"), Ast::UnaryOperationAstType},
     {QStringLiteral("Lambda"), Ast::LambdaAstType},
     {QStringLiteral("IfExpression"), Ast::IfExpressionAstType},
-- 
GitLab


From 981e8a5797cda877a33fd19d364b4bca215c76bd Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Tue, 15 Mar 2022 00:06:40 +0100
Subject: [PATCH 08/29] fix end element not being consumed sometimes

---
 parser/astfromxml.cpp                      |  6 ++---
 parser/astfromxml_detail/nodereader.h      | 28 +++++++++++++---------
 parser/astfromxml_detail/nodereader_impl.h | 28 ++++++++++++++++++++++
 3 files changed, 48 insertions(+), 14 deletions(-)

diff --git a/parser/astfromxml.cpp b/parser/astfromxml.cpp
index 777e1b8e..ae6a94db 100644
--- a/parser/astfromxml.cpp
+++ b/parser/astfromxml.cpp
@@ -19,7 +19,7 @@ struct ToEndElement {
 Ast* getSingleElement(Ast* parent, Stream& s)
 {
     auto ok = s.readNextStartElement();
-    qDebug() << "read element:" << s.name() << "at end" << s.atEnd() << "error" << s.errorString();
+    qDebug() << "read element:" << s.name() << "at end" << s.atEnd() << "error" << s.errorString()  << "ok" << ok;
     if (!ok) {
         return nullptr;
     }
@@ -27,8 +27,6 @@ Ast* getSingleElement(Ast* parent, Stream& s)
     auto const& name = s.name();
     auto const astType = astTypeFromString(name.toString());
 
-    ToEndElement toEnd(s);
-
     auto* ast = readTyped(parent, astType, s);
     if (ast)
         return ast;
@@ -51,6 +49,8 @@ void singleFromXml(Ast* parent, AstT*& ret, Stream& s)
 {
     auto* ast = getSingleElement(parent, s);
     ret = static_cast<AstT*>(ast);
+    [[maybe_unused]] auto end = s.readNextStartElement();
+    Q_ASSERT(!end && s.tokenType() == QXmlStreamReader::EndElement);
 }
 
 CodeAst* Python::astFromXml(QString const& data)
diff --git a/parser/astfromxml_detail/nodereader.h b/parser/astfromxml_detail/nodereader.h
index f67eda12..54d0e4e0 100644
--- a/parser/astfromxml_detail/nodereader.h
+++ b/parser/astfromxml_detail/nodereader.h
@@ -60,7 +60,6 @@ struct NodeReadHelper {
     template<int N>
     void readSingleChild(QStringRef const& childName, Stream& s) {
         auto const nameMatches = childName == *(r->ChildNames.begin() + N);
-        qDebug() << "checking child name:" << nameMatches << childName << *(r->ChildNames.begin() + N) << N;
         if (nameMatches) {
             r->readChild(ChildTag<N>{}, s);
         }
@@ -74,12 +73,16 @@ struct NodeReadHelper {
 
     void readChildren(Stream& s) {
         if constexpr (ChildCount > 0) {
-            qDebug() << " >> starting read list";
+            auto const name = s.name();
+            qDebug() << " >> starting read of child attribute list for " << name;
             while (s.readNextStartElement()) {
-                qDebug() << "read node attribute child:" << s.name();
+                auto childName = s.name();
+                qDebug() << "read child attribute of" << name << ":" << s.name();
                 readSingleChild<ChildCount - 1>(s.name(), s);
+                qDebug() << "done reading child attribute of" << name << ":" << childName;
+                qDebug() << "last read" << s.name() << "isEndTag" << (s.tokenType() == QXmlStreamReader::EndElement);
             }
-            qDebug() << " << finished read list:" << s.name();
+            qDebug() << " << finished read list:" << name << "read end:" << s.tokenType() << s.name();
         }
     };
 
@@ -91,14 +94,17 @@ template<typename Derived>
 void doReadNode(Derived* r, Stream& s)
 {
     using ThisReader = NodeReadHelper<
-    typename Derived::Attributes, Derived::AttributeNames.size(),
-    typename Derived::Children, Derived::ChildNames.size(),
-    Derived
+        typename Derived::Attributes, Derived::AttributeNames.size(),
+        typename Derived::Children, Derived::ChildNames.size(),
+        Derived
     >;
 
+    auto const name = s.name();
+    qDebug() << " ------- Deserializing:" << name;
     ThisReader reader(r, r->AttributeNames, r->ChildNames);
     reader.readAttributes(s);
     reader.readChildren(s);
+    qDebug() << " ++++++++ Done:" << name;
 }
 
 template<typename AstT>
@@ -117,6 +123,10 @@ struct BaseNodeReader
     static constexpr StringList ChildNames = {};
     static constexpr StringList AttributeNames = {};
 
+    BaseNodeReader(Ast* parent) {
+        result = new AstT(parent);
+    }
+
     AstT* read(Stream& s) {
         using Derived = NodeReader<AstT>;
         auto* derivedInstance = static_cast<Derived*>(this);
@@ -133,8 +143,4 @@ struct BaseNodeReader
     }
 
     AstT* result;
-
-    BaseNodeReader(Ast* parent) {
-        result = new AstT(parent);
-    }
 };
diff --git a/parser/astfromxml_detail/nodereader_impl.h b/parser/astfromxml_detail/nodereader_impl.h
index 4260473e..1d818a69 100644
--- a/parser/astfromxml_detail/nodereader_impl.h
+++ b/parser/astfromxml_detail/nodereader_impl.h
@@ -55,6 +55,34 @@ struct NodeReader<ArgumentsAst> : public BaseNodeReader<ArgumentsAst>
     READ_CHILD_IMPL(kwarg)
 };
 
+template<>
+struct NodeReader<ArgAst> : public BaseNodeReader<ArgAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { annotation };
+    static auto constexpr ChildNames = {"annotation"};
+
+    using Attributes = enum { argumentName };
+    static auto constexpr AttributeNames = {"arg"};
+
+    READ_CHILD_IMPL(annotation)
+
+    void readAttribute(AttributeTag<argumentName>, QStringRef const& value) {
+        result->argumentName = new Identifier(value.toString());
+    }
+
+    ~NodeReader() {
+        result->argumentName->rangeFrom(result);
+    };
+};
+
+template<>
+struct NodeReader<PassAst> : public BaseNodeReader<PassAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+};
+
 template<>
 struct NodeReader<ReturnAst> : public BaseNodeReader<ReturnAst>
 {
-- 
GitLab


From c26f0bfaa3dfa03b20f763a1774f2ec4f7fd3c2b Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Wed, 16 Mar 2022 22:35:40 +0100
Subject: [PATCH 09/29] use new end_col_offset and end_lineno from python

---
 parser/ast2xml.py                          |  2 ++
 parser/astfromxml_detail/nodereader.h      | 22 ++++++++++++++++++++--
 parser/astfromxml_detail/nodereader_impl.h |  1 +
 3 files changed, 23 insertions(+), 2 deletions(-)

diff --git a/parser/ast2xml.py b/parser/ast2xml.py
index d66009e0..6275a81e 100644
--- a/parser/ast2xml.py
+++ b/parser/ast2xml.py
@@ -19,6 +19,8 @@ class ASTSerializer(ast.NodeVisitor):
         if hasattr(node, "col_offset"):
             attrs["col_offset"] = node.col_offset
             attrs["lineno"] = node.lineno
+            attrs["end_col_offset"] = node.end_col_offset
+            attrs["end_lineno"] = node.end_lineno
         if name == "Constant":
             attrs["constant_type"] = type(node.value).__name__
         if name == "BinOp":
diff --git a/parser/astfromxml_detail/nodereader.h b/parser/astfromxml_detail/nodereader.h
index 54d0e4e0..9e00d576 100644
--- a/parser/astfromxml_detail/nodereader.h
+++ b/parser/astfromxml_detail/nodereader.h
@@ -14,8 +14,16 @@ using StringList = std::initializer_list<const char*>;
 template<int Attr> using AttributeTag = std::integral_constant<int, Attr>;
 template<int Child> using ChildTag = std::integral_constant<int, Child>;
 
-enum global_attributes {col_offset = -1, lineno = -2, last_global_attribute = lineno};
-StringList global_attribute_names = {"col_offset", "lineno"};
+enum global_attributes {
+    col_offset = -1, lineno = -2,
+    end_col_offset = -3, end_lineno = -4,
+    last_global_attribute = end_lineno
+};
+StringList constexpr global_attribute_names = {
+    "col_offset", "lineno",
+    "end_col_offset", "end_lineno",
+};
+static_assert(global_attribute_names.size() == -last_global_attribute);
 
 template<typename Attributes, int AttributeCount, typename Children, int ChildCount, typename Reader>
 struct NodeReadHelper {
@@ -35,8 +43,10 @@ struct NodeReadHelper {
             }
         }
         else {
+            qDebug() << "check:" << attributeName << *(global_attribute_names.begin() - (N+1));
             if (attributeName == *(global_attribute_names.begin() - (N+1))) {
                 r->readGlobalAttribute(AttributeTag<N>{}, attributeValue);
+                qDebug() << "read global:" << attributeName << attributeValue;
                 return;
             }
         }
@@ -142,5 +152,13 @@ struct BaseNodeReader
         result->startLine = value.toInt() - 1;
     }
 
+    void readGlobalAttribute(AttributeTag<end_col_offset>, QStringRef const& value) {
+        result->endCol = value.toInt();
+    }
+
+    void readGlobalAttribute(AttributeTag<end_lineno>, QStringRef const& value) {
+        result->endLine = value.toInt() - 1;
+    }
+
     AstT* result;
 };
diff --git a/parser/astfromxml_detail/nodereader_impl.h b/parser/astfromxml_detail/nodereader_impl.h
index 1d818a69..d80a92ba 100644
--- a/parser/astfromxml_detail/nodereader_impl.h
+++ b/parser/astfromxml_detail/nodereader_impl.h
@@ -74,6 +74,7 @@ struct NodeReader<ArgAst> : public BaseNodeReader<ArgAst>
 
     ~NodeReader() {
         result->argumentName->rangeFrom(result);
+        result->copyRange(result->argumentName);
     };
 };
 
-- 
GitLab


From 9eb4e97a9a78e88cf44c4d5b354c6d8efe90ed0b Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Fri, 18 Mar 2022 23:02:27 +0100
Subject: [PATCH 10/29] implement ClassDef, Call, Expr, List, Tuple, Subscript,
 Slice

---
 duchain/tests/pyduchaintest.cpp            |   1 +
 parser/ast2xml.py                          |   4 +-
 parser/astfromxml_detail/nodereader.h      |   4 +
 parser/astfromxml_detail/nodereader_impl.h | 129 ++++++++++++++++++---
 parser/astfromxml_detail/typemap.h         |   3 +-
 parser/astfromxml_detail/typeswitch.h      |   3 +-
 6 files changed, 126 insertions(+), 18 deletions(-)

diff --git a/duchain/tests/pyduchaintest.cpp b/duchain/tests/pyduchaintest.cpp
index 35cc206a..6b93d87f 100644
--- a/duchain/tests/pyduchaintest.cpp
+++ b/duchain/tests/pyduchaintest.cpp
@@ -634,6 +634,7 @@ void PyDUChainTest::testSimple_data()
     QTest::newRow("bool") << "a = True" << 1 << 0;
     QTest::newRow("op2") << "a = True and True;" << 1 << 0;
     QTest::newRow("fndef") << "def f(): return 0" << 1 << 0;
+    QTest::newRow("classdef") << "def foo(x): pass" << 1 << 0;
 }
 
 class AttributeRangeTestVisitor : public AstDefaultVisitor {
diff --git a/parser/ast2xml.py b/parser/ast2xml.py
index 6275a81e..e0d5c8e9 100644
--- a/parser/ast2xml.py
+++ b/parser/ast2xml.py
@@ -37,7 +37,9 @@ class ASTSerializer(ast.NodeVisitor):
                             self.generic_visit(entry)
                 elif attr_val is None:
                     pass
-                elif issubclass(type(attr_val), ast.AST) or type(attr_val).__name__ == "ellipsis":
+                elif type(attr_val).__name__ == "ellipsis":
+                    pass
+                elif issubclass(type(attr_val), ast.AST):
                     with xf.element(attr) as name_elem:
                         self.generic_visit(attr_val)
                 else:
diff --git a/parser/astfromxml_detail/nodereader.h b/parser/astfromxml_detail/nodereader.h
index 9e00d576..5d50d207 100644
--- a/parser/astfromxml_detail/nodereader.h
+++ b/parser/astfromxml_detail/nodereader.h
@@ -94,6 +94,10 @@ struct NodeReadHelper {
             }
             qDebug() << " << finished read list:" << name << "read end:" << s.tokenType() << s.name();
         }
+        else {
+            qDebug() << " ** " << s.name() << "has no children, skipping it.";
+            s.readNextStartElement();
+        }
     };
 
     Reader* r;
diff --git a/parser/astfromxml_detail/nodereader_impl.h b/parser/astfromxml_detail/nodereader_impl.h
index d80a92ba..6f9d60c8 100644
--- a/parser/astfromxml_detail/nodereader_impl.h
+++ b/parser/astfromxml_detail/nodereader_impl.h
@@ -8,6 +8,17 @@
     void readChild(ChildTag<name>, Stream& s) { singleFromXml(result, result->name, s); }
 #define READ_CHILD_LIST_IMPL(name) \
     void readChild(ChildTag<name>, Stream& s) { listFromXml(result, result->name, s); }
+#define READ_IDENTIFIER_IMPL(name) \
+    void readAttribute(AttributeTag<name>, QStringRef const& value) { \
+        result->name = new Identifier(value.toString()); \
+    } \
+    ~NodeReader() { \
+        result->name->rangeFrom(result); \
+    }
+#define IGNORE_CHILD(name) \
+    void readChild(ChildTag<name>, Stream& s) { [[maybe_unused]] Ast* r; singleFromXml(result, r, s); }
+#define IGNORE_CHILD_LIST(name) \
+    void readChild(ChildTag<name>, Stream& s) { [[maybe_unused]] QList<Ast*> r; listFromXml(result, r, s); }
 
 template<>
 struct NodeReader<FunctionDefinitionAst> : public BaseNodeReader<FunctionDefinitionAst>
@@ -20,18 +31,11 @@ struct NodeReader<FunctionDefinitionAst> : public BaseNodeReader<FunctionDefinit
     using Children = enum { arguments, decorators, body, returns };
     static auto constexpr ChildNames = {"args", "decorator_list", "body", "returns"};
 
-    void readAttribute(AttributeTag<name>, QStringRef const& value) {
-        result->name = new Identifier(value.toString());
-    }
-
     READ_CHILD_IMPL(arguments)
     READ_CHILD_IMPL(returns)
     READ_CHILD_LIST_IMPL(body)
     READ_CHILD_LIST_IMPL(decorators)
-
-    ~NodeReader() {
-        result->name->rangeFrom(result);
-    }
+    READ_IDENTIFIER_IMPL(name)
 };
 
 template<>
@@ -103,13 +107,7 @@ struct NodeReader<NameAst> : public BaseNodeReader<NameAst>
     using Attributes = enum { identifier };
     static auto constexpr AttributeNames = {"id"};
 
-    void readAttribute(AttributeTag<identifier>, QStringRef const& value) {
-        result->identifier = new Identifier(value.toString());
-    }
-
-    ~NodeReader() {
-        result->identifier->rangeFrom(result);
-    }
+    READ_IDENTIFIER_IMPL(identifier)
 };
 
 template<>
@@ -176,3 +174,104 @@ struct NodeReader<ConstantAst> : public BaseNodeReader<ConstantAst>
         }
     }
 };
+
+template<>
+struct NodeReader<ClassDefinitionAst> : public BaseNodeReader<ClassDefinitionAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Attributes = enum { name };
+    static auto constexpr AttributeNames = { "name" };
+
+    using Children = enum { baseClasses, body, decorators, keywords };
+    static auto constexpr ChildNames = { "bases", "body", "decorator_list", "keywords" };
+
+    READ_CHILD_LIST_IMPL(baseClasses)
+    READ_CHILD_LIST_IMPL(body)
+    READ_CHILD_LIST_IMPL(decorators)
+    IGNORE_CHILD_LIST(keywords)
+    READ_IDENTIFIER_IMPL(name)
+};
+
+template<>
+struct NodeReader<CallAst> : public BaseNodeReader<CallAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { function, arguments, keywords };
+    static auto constexpr ChildNames = { "func", "args", "keywords" };
+
+    READ_CHILD_IMPL(function)
+    READ_CHILD_LIST_IMPL(arguments)
+    READ_CHILD_LIST_IMPL(keywords)
+};
+
+template<>
+struct NodeReader<ExpressionAst> : public BaseNodeReader<ExpressionAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { value };
+    static auto constexpr ChildNames = { "value" };
+
+    READ_CHILD_IMPL(value)
+};
+
+template<>
+struct NodeReader<ListAst> : public BaseNodeReader<ListAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { elements };
+    static auto constexpr ChildNames = { "elts" };
+
+    READ_CHILD_LIST_IMPL(elements)
+};
+
+template<>
+struct NodeReader<DictAst> : public BaseNodeReader<DictAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { keys, values };
+    static auto constexpr ChildNames = { "keys", "values" };
+
+    READ_CHILD_LIST_IMPL(keys)
+    READ_CHILD_LIST_IMPL(values)
+};
+
+template<>
+struct NodeReader<TupleAst> : public BaseNodeReader<TupleAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { elements };
+    static auto constexpr ChildNames = { "elts" };
+
+    READ_CHILD_LIST_IMPL(elements)
+};
+
+template<>
+struct NodeReader<SubscriptAst> : public BaseNodeReader<SubscriptAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { value, slice };
+    static auto constexpr ChildNames = { "value", "slice" };
+
+    READ_CHILD_IMPL(value)
+    READ_CHILD_IMPL(slice)
+};
+
+template<>
+struct NodeReader<SliceAst> : public BaseNodeReader<SliceAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { lower, upper, step};
+    static auto constexpr ChildNames = { "lower", "upper", "step" };
+
+    READ_CHILD_IMPL(lower)
+    READ_CHILD_IMPL(upper)
+    READ_CHILD_IMPL(step)
+};
diff --git a/parser/astfromxml_detail/typemap.h b/parser/astfromxml_detail/typemap.h
index 88d46094..9f829adc 100644
--- a/parser/astfromxml_detail/typemap.h
+++ b/parser/astfromxml_detail/typemap.h
@@ -5,6 +5,7 @@
 using namespace Python;
 
 QMap<QString, Ast::AstType> astTypes = {
+    {QStringLiteral("Expr"), Ast::ExpressionAstType},
     {QStringLiteral("AsyncFunctionDef"), Ast::FunctionDefinitionAstType},
     {QStringLiteral("FunctionDef"), Ast::FunctionDefinitionAstType},
     {QStringLiteral("Assign"), Ast::AssignmentAstType},
@@ -13,7 +14,7 @@ QMap<QString, Ast::AstType> astTypes = {
     {QStringLiteral("arguments"), Ast::ArgumentsAstType},
     {QStringLiteral("arg"), Ast::ArgAstType},
     {QStringLiteral("Keyword"), Ast::KeywordAstType},
-    {QStringLiteral("ClassDefinition"), Ast::ClassDefinitionAstType},
+    {QStringLiteral("ClassDef"), Ast::ClassDefinitionAstType},
     {QStringLiteral("Return"), Ast::ReturnAstType},
     {QStringLiteral("Delete"), Ast::DeleteAstType},
     {QStringLiteral("For"), Ast::ForAstType},
diff --git a/parser/astfromxml_detail/typeswitch.h b/parser/astfromxml_detail/typeswitch.h
index 8a04257c..a5b613ba 100644
--- a/parser/astfromxml_detail/typeswitch.h
+++ b/parser/astfromxml_detail/typeswitch.h
@@ -127,9 +127,10 @@ Ast* readTyped(Ast* parent, Python::Ast::AstType astType, Stream& s) {
             return NodeReader<ExceptionHandlerAst>(parent).read(s);
         case Ast::AliasAstType:
             return NodeReader<AliasAst>(parent).read(s);
+        case Ast::ExpressionAstType:
+            return NodeReader<ExpressionAst>(parent).read(s);
         case Ast::LastStatementType:
         case Ast::StatementAstType:
-        case Ast::ExpressionAstType:
         case Ast::LastExpressionType:
         case Ast::IdentifierAstType:
         case Ast::LastAstType:
-- 
GitLab


From b675296af215f7b20cbc8c9f518bd7e84d0fdd8c Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Fri, 18 Mar 2022 23:07:14 +0100
Subject: [PATCH 11/29] implement BoolOp

---
 parser/ast2xml.py                          |  2 ++
 parser/astfromxml_detail/nodereader_impl.h | 13 ++++++++++++-
 parser/astfromxml_detail/typemap.h         |  2 +-
 3 files changed, 15 insertions(+), 2 deletions(-)

diff --git a/parser/ast2xml.py b/parser/ast2xml.py
index e0d5c8e9..a3220532 100644
--- a/parser/ast2xml.py
+++ b/parser/ast2xml.py
@@ -25,6 +25,8 @@ class ASTSerializer(ast.NodeVisitor):
             attrs["constant_type"] = type(node.value).__name__
         if name == "BinOp":
             attrs["op"] = type(node.op).__name__
+        if name == "BoolOp":
+            attrs["op"] = type(node.op).__name__
         plain_attrs = {k: str(v) for k, v in attrs.items() if type(v) in plain_types}
         non_plain_attrs = {k: v for k, v in attrs.items() if type(v) not in plain_types}
         with xf.element(name, **plain_attrs) as elem:
diff --git a/parser/astfromxml_detail/nodereader_impl.h b/parser/astfromxml_detail/nodereader_impl.h
index 6f9d60c8..80d7a75b 100644
--- a/parser/astfromxml_detail/nodereader_impl.h
+++ b/parser/astfromxml_detail/nodereader_impl.h
@@ -268,10 +268,21 @@ struct NodeReader<SliceAst> : public BaseNodeReader<SliceAst>
 {
     using BaseNodeReader::BaseNodeReader;
 
-    using Children = enum { lower, upper, step};
+    using Children = enum { lower, upper, step };
     static auto constexpr ChildNames = { "lower", "upper", "step" };
 
     READ_CHILD_IMPL(lower)
     READ_CHILD_IMPL(upper)
     READ_CHILD_IMPL(step)
 };
+
+template<>
+struct NodeReader<BooleanOperationAst> : public BaseNodeReader<BooleanOperationAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { values };
+    static auto constexpr ChildNames = { "values" };
+
+    READ_CHILD_LIST_IMPL(values)
+};
diff --git a/parser/astfromxml_detail/typemap.h b/parser/astfromxml_detail/typemap.h
index 9f829adc..8f1053dd 100644
--- a/parser/astfromxml_detail/typemap.h
+++ b/parser/astfromxml_detail/typemap.h
@@ -39,7 +39,7 @@ QMap<QString, Ast::AstType> astTypes = {
     {QStringLiteral("Call"), Ast::CallAstType},
     {QStringLiteral("Attribute"), Ast::AttributeAstType},
     {QStringLiteral("DictionaryComprehension"), Ast::DictionaryComprehensionAstType},
-    {QStringLiteral("BooleanOperation"), Ast::BooleanOperationAstType},
+    {QStringLiteral("BoolOp"), Ast::BooleanOperationAstType},
     {QStringLiteral("BinOp"), Ast::BinaryOperationAstType},
     {QStringLiteral("UnaryOperation"), Ast::UnaryOperationAstType},
     {QStringLiteral("Lambda"), Ast::LambdaAstType},
-- 
GitLab


From 767592904cce6ac4751baaf8206016fe9b6b9972 Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Fri, 18 Mar 2022 23:43:58 +0100
Subject: [PATCH 12/29] implement Attribute, Alias, Import

It seems like we can use the new end_col, end_line for Attributes
instead of our crude workaround.
---
 parser/astfromxml_detail/nodereader.h      | 17 +++---
 parser/astfromxml_detail/nodereader_impl.h | 67 ++++++++++++++++++++++
 parser/astfromxml_detail/typemap.h         |  2 +-
 parser/rangefixvisitor.cpp                 |  3 +
 parser/rangefixvisitor.h                   |  2 +
 5 files changed, 81 insertions(+), 10 deletions(-)

diff --git a/parser/astfromxml_detail/nodereader.h b/parser/astfromxml_detail/nodereader.h
index 5d50d207..56816b64 100644
--- a/parser/astfromxml_detail/nodereader.h
+++ b/parser/astfromxml_detail/nodereader.h
@@ -43,10 +43,9 @@ struct NodeReadHelper {
             }
         }
         else {
-            qDebug() << "check:" << attributeName << *(global_attribute_names.begin() - (N+1));
             if (attributeName == *(global_attribute_names.begin() - (N+1))) {
+                qDebug() << "read global attribute:" << attributeName << attributeValue;
                 r->readGlobalAttribute(AttributeTag<N>{}, attributeValue);
-                qDebug() << "read global:" << attributeName << attributeValue;
                 return;
             }
         }
@@ -58,12 +57,9 @@ struct NodeReadHelper {
     }
 
     void readAttributes(Stream& s) {
-        if constexpr (AttributeCount > 0) {
-            auto const& attributes = s.attributes();
-            for (auto const& attr: attributes) {
-                qDebug() << "read attribute:" << attr.name() << attr.value();
-                tryReadAttributes<AttributeCount - 1>(attr.name(), attr.value());
-            }
+        auto const& attributes = s.attributes();
+        for (auto const& attr: attributes) {
+            tryReadAttributes<AttributeCount - 1>(attr.name(), attr.value());
         }
     }
 
@@ -153,14 +149,17 @@ struct BaseNodeReader
     }
 
     void readGlobalAttribute(AttributeTag<lineno>, QStringRef const& value) {
+        // minus one because our lines are zero-indexed
         result->startLine = value.toInt() - 1;
     }
 
     void readGlobalAttribute(AttributeTag<end_col_offset>, QStringRef const& value) {
-        result->endCol = value.toInt();
+        // minus one because our ranges are [a:b] but Python's are [a:b)
+        result->endCol = value.toInt() - 1;
     }
 
     void readGlobalAttribute(AttributeTag<end_lineno>, QStringRef const& value) {
+        // minus one because our lines are zero-indexed
         result->endLine = value.toInt() - 1;
     }
 
diff --git a/parser/astfromxml_detail/nodereader_impl.h b/parser/astfromxml_detail/nodereader_impl.h
index 80d7a75b..ba64819d 100644
--- a/parser/astfromxml_detail/nodereader_impl.h
+++ b/parser/astfromxml_detail/nodereader_impl.h
@@ -286,3 +286,70 @@ struct NodeReader<BooleanOperationAst> : public BaseNodeReader<BooleanOperationA
 
     READ_CHILD_LIST_IMPL(values)
 };
+
+template<>
+struct NodeReader<AttributeAst> : public BaseNodeReader<AttributeAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Attributes = enum { attribute };
+    static auto constexpr AttributeNames = { "attr" };
+
+    using Children = enum { value };
+    static auto constexpr ChildNames = { "value" };
+
+    READ_CHILD_IMPL(value)
+
+    void readAttribute(AttributeTag<value>, QStringRef const& value) {
+        result->attribute = new Identifier(value.toString());
+    }
+
+    ~NodeReader() {
+        if (!result->attribute) {
+            return;
+        }
+        result->attribute->copyRange(result);
+        result->attribute->startCol = result->endCol - result->attribute->value.length() + 1;
+        result->attribute->startLine = result->attribute->endLine;
+        result->copyRange(result->attribute);
+    }
+};
+
+template<>
+struct NodeReader<ImportAst> : public BaseNodeReader<ImportAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { names };
+    static auto constexpr ChildNames = { "names" };
+
+    READ_CHILD_LIST_IMPL(names)
+};
+
+template<>
+struct NodeReader<AliasAst> : public BaseNodeReader<AliasAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Attributes = enum { name, asName };
+    static auto constexpr AttributeNames = { "name", "asname" };
+
+    void readAttribute(AttributeTag<name>, QStringRef const& value) {
+        result->name = new Identifier(value.toString());
+    }
+
+    void readAttribute(AttributeTag<asName>, QStringRef const& value) {
+        if (value != "None") {
+            result->asName = new Identifier(value.toString());
+        }
+    }
+
+    ~NodeReader() {
+        if (result->name) {
+            result->name->copyRange(result);
+        }
+        if (result->asName) {
+            result->asName->copyRange(result);
+        }
+    }
+};
diff --git a/parser/astfromxml_detail/typemap.h b/parser/astfromxml_detail/typemap.h
index 8f1053dd..63042e42 100644
--- a/parser/astfromxml_detail/typemap.h
+++ b/parser/astfromxml_detail/typemap.h
@@ -67,5 +67,5 @@ QMap<QString, Ast::AstType> astTypes = {
     {QStringLiteral("AssignmentExpression"), Ast::AssignmentExpressionAstType},
     {QStringLiteral("Module"), Ast::CodeAstType},
     {QStringLiteral("ExceptionHandler"), Ast::ExceptionHandlerAstType},
-    {QStringLiteral("Alias"), Ast::AliasAstType},
+    {QStringLiteral("alias"), Ast::AliasAstType},
 };
diff --git a/parser/rangefixvisitor.cpp b/parser/rangefixvisitor.cpp
index be9bbb60..f6c69884 100644
--- a/parser/rangefixvisitor.cpp
+++ b/parser/rangefixvisitor.cpp
@@ -71,6 +71,7 @@ void RangeFixVisitor::visitClassDefinition(ClassDefinitionAst* node) {
     AstDefaultVisitor::visitClassDefinition(node);
 };
 
+#if 0
 void RangeFixVisitor::visitAttribute(AttributeAst* node) {
     // Work around the weird way to count columns in Python's AST module.
 
@@ -147,6 +148,7 @@ void RangeFixVisitor::visitAttribute(AttributeAst* node) {
 
     AstDefaultVisitor::visitAttribute(node);
 };
+#endif
 
 // alias for imports (import foo as bar, baz as bang)
 // no strings, brackets, or whatever are allowed here, so the "parser"
@@ -241,6 +243,7 @@ void RangeFixVisitor::cutDefinitionPreamble(Ast* fixNode, const QString& defKeyw
 
     // cut away decorators
     while ( currentLine < lines.size() ) {
+        qDebug() << "line" << currentLine << lines.size() << defKeyword << fixNode->astType;
         if ( lines.at(currentLine).trimmed().remove(' ').remove('\t').startsWith(defKeyword) ) {
             // it's not a decorator, so stop skipping lines.
             break;
diff --git a/parser/rangefixvisitor.h b/parser/rangefixvisitor.h
index ce474f29..eb8296b6 100644
--- a/parser/rangefixvisitor.h
+++ b/parser/rangefixvisitor.h
@@ -26,7 +26,9 @@ public:
     void visitCode(Python::CodeAst* node) override;
     void visitFunctionDefinition(FunctionDefinitionAst* node) override;
     void visitClassDefinition(ClassDefinitionAst* node) override;
+#if 0
     void visitAttribute(AttributeAst* node) override;
+#endif
     void visitImport(ImportAst* node) override;
     void visitExceptionHandler(ExceptionHandlerAst* node) override;
     void visitString(Python::StringAst* node) override;
-- 
GitLab


From 58257652aa238d0dbc99558ec7aa3e63ab7f9ef0 Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Sat, 19 Mar 2022 11:22:54 +0100
Subject: [PATCH 13/29] fix docstrings for functions and classes

---
 duchain/declarationbuilder.cpp | 30 ++++++++++++++++++++++--------
 duchain/declarationbuilder.h   |  3 ++-
 parser/ast.cpp                 |  2 +-
 parser/ast.h                   |  4 ++--
 parser/rangefixvisitor.cpp     |  1 -
 5 files changed, 27 insertions(+), 13 deletions(-)

diff --git a/duchain/declarationbuilder.cpp b/duchain/declarationbuilder.cpp
index 027d3c06..accd7ec7 100644
--- a/duchain/declarationbuilder.cpp
+++ b/duchain/declarationbuilder.cpp
@@ -1093,9 +1093,9 @@ void DeclarationBuilder::assignToName(NameAst* target, const DeclarationBuilder:
     else {
         DUChainWriteLocker lock;
         Declaration* dec = visitVariableDeclaration<Declaration>(target, nullptr, element.type);
-        if ( dec && m_lastComment && ! m_lastComment->usedAsComment ) {
-            dec->setComment(m_lastComment->value);
-            m_lastComment->usedAsComment = true;
+        if ( dec && !m_lastComment.isEmpty() ) {
+            dec->setComment(m_lastComment);
+            m_lastComment.clear();
         }
         /** DEBUG **/
         if ( element.type && dec ) {
@@ -1584,12 +1584,15 @@ void DeclarationBuilder::visitFunctionDefinition( FunctionDefinitionAst* node )
 QString DeclarationBuilder::getDocstring(QList< Python::Ast* > body) const
 {
     if ( ! body.isEmpty() && body.first()->astType == Ast::ExpressionAstType 
-            && static_cast<ExpressionAst*>(body.first())->value->astType == Ast::StringAstType )
+            && static_cast<ExpressionAst*>(body.first())->value->astType == Ast::ConstantAstType )
     {
         // If the first statement in a function/class body is a string, then that is the docstring.
-        StringAst* docstring = static_cast<StringAst*>(static_cast<ExpressionAst*>(body.first())->value);
+        ConstantAst* docstring = static_cast<ConstantAst*>(static_cast<ExpressionAst*>(body.first())->value);
         docstring->usedAsComment = true;
-        return docstring->value.trimmed();
+        if (auto* string = std::get_if<QString>(&docstring->value)) {
+            qDebug() << "setting function docstring:" << *string;
+            return string->trimmed();
+        }
     }
     return QString();
 }
@@ -1840,15 +1843,26 @@ void DeclarationBuilder::visitArguments( ArgumentsAst* node )
 
 void DeclarationBuilder::visitString(StringAst* node) {
     if ( node->parent && node->parent->astType == Ast::ExpressionAstType ) {
-        m_lastComment = node;
+        m_lastComment = node->value;
     }
     DeclarationBuilderBase::visitString(node);
 }
 
+void DeclarationBuilder::visitConstant(ConstantAst* node) {
+    if ( std::holds_alternative<QString>(node->value) ) {
+        qDebug() << "visiting string constant" << node->parent->astType;
+        if ( node->parent && node->parent->astType == Ast::ExpressionAstType ) {
+            m_lastComment = std::get<QString>(node->value);
+            qDebug() << "setting last comment" << m_lastComment;
+        }
+    }
+    DeclarationBuilderBase::visitConstant(node);
+}
+
 void DeclarationBuilder::visitNode(Ast* node) {
     DeclarationBuilderBase::visitNode(node);
     if ( node && node->astType >= Ast::StatementAstType && node->astType <= Ast::LastStatementType) {
-        m_lastComment = nullptr;
+        m_lastComment.clear();
     }
 }
 
diff --git a/duchain/declarationbuilder.h b/duchain/declarationbuilder.h
index 58d13b59..44458096 100644
--- a/duchain/declarationbuilder.h
+++ b/duchain/declarationbuilder.h
@@ -96,6 +96,7 @@ protected:
     void visitIf(IfAst* node) override;
     void visitString(StringAst* node) override;
     void visitNode(Ast* node) override;
+    void visitConstant(ConstantAst* node) override;
 
 protected:
     enum VisitVariableFlags {
@@ -265,7 +266,7 @@ private:
     // missing modules, for not reporting them as unknown variables
     QVector<IndexedString> m_missingModules;
 
-    StringAst* m_lastComment = nullptr;
+    QString m_lastComment;
 };
 
 }
diff --git a/parser/ast.cpp b/parser/ast.cpp
index 4581fe40..a8ffa0bf 100644
--- a/parser/ast.cpp
+++ b/parser/ast.cpp
@@ -96,7 +96,7 @@ CompareAst::CompareAst(Ast* parent): ExpressionAst(parent, Ast::CompareAstType),
     
 }
 
-ConstantAst::ConstantAst(Ast* parent) : ExpressionAst(parent, Ast::ConstantAstType), value(QString())
+ConstantAst::ConstantAst(Ast* parent) : ExpressionAst(parent, Ast::ConstantAstType), value(QString()), usedAsComment(false)
 {
 
 }
diff --git a/parser/ast.h b/parser/ast.h
index f5d4c3f6..a53ab513 100644
--- a/parser/ast.h
+++ b/parser/ast.h
@@ -1,12 +1,11 @@
 /*
     SPDX-FileCopyrightText: 2007 Andreas Pakulat <apaku@gmx.de>
     SPDX-FileCopyrightText: 2012 Patrick Spendrin <ps_ml@gmx.de>
+    SPDX-FileCopyrightText: 2009-2022 Sven Brauch <mail@svenbrauch.de>
 
     SPDX-License-Identifier: LGPL-2.0-or-later
 */
 
-// The Python 3.4 Language Reference was used as basis for this AST
-
 #ifndef PYTHON_AST_H
 #define PYTHON_AST_H
 
@@ -585,6 +584,7 @@ class KDEVPYTHONPARSER_EXPORT ConstantAst : public ExpressionAst {
 public:
     ConstantAst(Ast* parent);
     std::variant<int, float, QString> value;
+    bool usedAsComment;
 };
 
 class KDEVPYTHONPARSER_EXPORT NumberAst : public ExpressionAst {
diff --git a/parser/rangefixvisitor.cpp b/parser/rangefixvisitor.cpp
index f6c69884..626c1c50 100644
--- a/parser/rangefixvisitor.cpp
+++ b/parser/rangefixvisitor.cpp
@@ -243,7 +243,6 @@ void RangeFixVisitor::cutDefinitionPreamble(Ast* fixNode, const QString& defKeyw
 
     // cut away decorators
     while ( currentLine < lines.size() ) {
-        qDebug() << "line" << currentLine << lines.size() << defKeyword << fixNode->astType;
         if ( lines.at(currentLine).trimmed().remove(' ').remove('\t').startsWith(defKeyword) ) {
             // it's not a decorator, so stop skipping lines.
             break;
-- 
GitLab


From 1b8fa6e1cb634b07e677d74a47735f36aa0ef5c5 Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Sat, 19 Mar 2022 11:23:38 +0100
Subject: [PATCH 14/29] add missing license headers

---
 .gitignore                                 | 1 +
 duchain/declarationbuilder.cpp             | 2 +-
 parser/astfromxml.cpp                      | 6 ++++++
 parser/astfromxml.h                        | 6 ++++++
 parser/astfromxml_detail/fromxml_fwd.h     | 6 ++++++
 parser/astfromxml_detail/nodereader.h      | 6 ++++++
 parser/astfromxml_detail/nodereader_impl.h | 6 ++++++
 parser/astfromxml_detail/operators.h       | 6 ++++++
 parser/astfromxml_detail/typemap.h         | 6 ++++++
 parser/astfromxml_detail/typeswitch.h      | 6 ++++++
 10 files changed, 50 insertions(+), 1 deletion(-)

diff --git a/.gitignore b/.gitignore
index 54b4d2f4..2707f463 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,6 +1,7 @@
 *~
 .svn/*
 build/*
+build-*/*
 .kdev_include_paths
 *.swp
 *.pyc
diff --git a/duchain/declarationbuilder.cpp b/duchain/declarationbuilder.cpp
index accd7ec7..c1678d52 100644
--- a/duchain/declarationbuilder.cpp
+++ b/duchain/declarationbuilder.cpp
@@ -1,7 +1,7 @@
 /*
     SPDX-FileCopyrightText: 2007 Piyush verma <piyush.verma@gmail.com>
     SPDX-FileCopyrightText: 2007 Andreas Pakulat <apaku@gmx.de>
-    SPDX-FileCopyrightText: 2010-2016 Sven Brauch <svenbrauch@googlemail.com>
+    SPDX-FileCopyrightText: 2010-2022 Sven Brauch <svenbrauch@googlemail.com>
     SPDX-FileCopyrightText: 2016 Francis Herne <mail@flherne.uk>
 
     SPDX-License-Identifier: GPL-2.0-or-later
diff --git a/parser/astfromxml.cpp b/parser/astfromxml.cpp
index ae6a94db..8c572623 100644
--- a/parser/astfromxml.cpp
+++ b/parser/astfromxml.cpp
@@ -1,3 +1,9 @@
+/*
+ *  SPDX-FileCopyrightText: 2022 Sven Brauch <mail@svenbrauch.de>
+ *
+ *  SPDX-License-Identifier: LGPL-2.0-or-later
+ */
+
 #include "astfromxml.h"
 
 #include "astfromxml_detail/typemap.h"
diff --git a/parser/astfromxml.h b/parser/astfromxml.h
index bb5039ba..4601853f 100644
--- a/parser/astfromxml.h
+++ b/parser/astfromxml.h
@@ -1,3 +1,9 @@
+/*
+ *  SPDX-FileCopyrightText: 2022 Sven Brauch <mail@svenbrauch.de>
+ *
+ *  SPDX-License-Identifier: LGPL-2.0-or-later
+ */
+
 #pragma once
 
 #include <QXmlStreamReader>
diff --git a/parser/astfromxml_detail/fromxml_fwd.h b/parser/astfromxml_detail/fromxml_fwd.h
index 68ec551e..8a34513d 100644
--- a/parser/astfromxml_detail/fromxml_fwd.h
+++ b/parser/astfromxml_detail/fromxml_fwd.h
@@ -1,3 +1,9 @@
+/*
+ *  SPDX-FileCopyrightText: 2022 Sven Brauch <mail@svenbrauch.de>
+ *
+ *  SPDX-License-Identifier: LGPL-2.0-or-later
+ */
+
 #pragma once
 
 #include <QXmlStreamReader>
diff --git a/parser/astfromxml_detail/nodereader.h b/parser/astfromxml_detail/nodereader.h
index 56816b64..c51cb702 100644
--- a/parser/astfromxml_detail/nodereader.h
+++ b/parser/astfromxml_detail/nodereader.h
@@ -1,3 +1,9 @@
+/*
+ *  SPDX-FileCopyrightText: 2022 Sven Brauch <mail@svenbrauch.de>
+ *
+ *  SPDX-License-Identifier: LGPL-2.0-or-later
+ */
+
 #pragma once
 
 #include <initializer_list>
diff --git a/parser/astfromxml_detail/nodereader_impl.h b/parser/astfromxml_detail/nodereader_impl.h
index ba64819d..27a19c3f 100644
--- a/parser/astfromxml_detail/nodereader_impl.h
+++ b/parser/astfromxml_detail/nodereader_impl.h
@@ -1,3 +1,9 @@
+/*
+ *  SPDX-FileCopyrightText: 2022 Sven Brauch <mail@svenbrauch.de>
+ *
+ *  SPDX-License-Identifier: LGPL-2.0-or-later
+ */
+
 #pragma once
 
 #include "nodereader.h"
diff --git a/parser/astfromxml_detail/operators.h b/parser/astfromxml_detail/operators.h
index 8a8569b1..68bdb910 100644
--- a/parser/astfromxml_detail/operators.h
+++ b/parser/astfromxml_detail/operators.h
@@ -1,3 +1,9 @@
+/*
+ *  SPDX-FileCopyrightText: 2022 Sven Brauch <mail@svenbrauch.de>
+ *
+ *  SPDX-License-Identifier: LGPL-2.0-or-later
+ */
+
 #pragma once
 
 #include "ast.h"
diff --git a/parser/astfromxml_detail/typemap.h b/parser/astfromxml_detail/typemap.h
index 63042e42..b4cd9e3b 100644
--- a/parser/astfromxml_detail/typemap.h
+++ b/parser/astfromxml_detail/typemap.h
@@ -1,3 +1,9 @@
+/*
+ *  SPDX-FileCopyrightText: 2022 Sven Brauch <mail@svenbrauch.de>
+ *
+ *  SPDX-License-Identifier: LGPL-2.0-or-later
+ */
+
 #pragma once
 
 #include "ast.h"
diff --git a/parser/astfromxml_detail/typeswitch.h b/parser/astfromxml_detail/typeswitch.h
index a5b613ba..0f3669e8 100644
--- a/parser/astfromxml_detail/typeswitch.h
+++ b/parser/astfromxml_detail/typeswitch.h
@@ -1,3 +1,9 @@
+/*
+ *  SPDX-FileCopyrightText: 2022 Sven Brauch <mail@svenbrauch.de>
+ *
+ *  SPDX-License-Identifier: LGPL-2.0-or-later
+ */
+
 #pragma once
 #include "fromxml_fwd.h"
 #include "nodereader.h"
-- 
GitLab


From ebe0e7a0cd2db557d3c0eaf912642b8eef9c27b9 Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Sat, 19 Mar 2022 12:16:58 +0100
Subject: [PATCH 15/29] add Set, ImportFrom, List,Set,DictComp, UnaryOp,

Lambda, JoinedStr, AugAssign, Delete, For, While, If, With,
Compare, Generator, Keyword, Raise, Starred, Try, ExceptHandler,
FormattedValue, AnnotationAssignment

This language sure has a lot of features.
---
 parser/ast2xml.py                          |   4 +
 parser/astfromxml_detail/nodereader_impl.h | 348 +++++++++++++++++++++
 parser/astfromxml_detail/operators.h       |   4 +
 parser/astfromxml_detail/typemap.h         |  22 +-
 4 files changed, 367 insertions(+), 11 deletions(-)

diff --git a/parser/ast2xml.py b/parser/ast2xml.py
index a3220532..e8dbed04 100644
--- a/parser/ast2xml.py
+++ b/parser/ast2xml.py
@@ -14,6 +14,8 @@ class ASTSerializer(ast.NodeVisitor):
         self.xf = xf
 
     def generic_visit(self, node):
+        if node is None:
+            return
         name = type(node).__name__
         attrs = {k: getattr(node, k) for k in node._fields} if hasattr(node, "_fields") else dict()
         if hasattr(node, "col_offset"):
@@ -27,6 +29,8 @@ class ASTSerializer(ast.NodeVisitor):
             attrs["op"] = type(node.op).__name__
         if name == "BoolOp":
             attrs["op"] = type(node.op).__name__
+        if name == "UnaryOp":
+            attrs["op"] = type(node.op).__name__
         plain_attrs = {k: str(v) for k, v in attrs.items() if type(v) in plain_types}
         non_plain_attrs = {k: v for k, v in attrs.items() if type(v) not in plain_types}
         with xf.element(name, **plain_attrs) as elem:
diff --git a/parser/astfromxml_detail/nodereader_impl.h b/parser/astfromxml_detail/nodereader_impl.h
index 27a19c3f..ea137f1e 100644
--- a/parser/astfromxml_detail/nodereader_impl.h
+++ b/parser/astfromxml_detail/nodereader_impl.h
@@ -257,6 +257,17 @@ struct NodeReader<TupleAst> : public BaseNodeReader<TupleAst>
     READ_CHILD_LIST_IMPL(elements)
 };
 
+template<>
+struct NodeReader<SetAst> : public BaseNodeReader<SetAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { elements };
+    static auto constexpr ChildNames = { "elts" };
+
+    READ_CHILD_LIST_IMPL(elements)
+};
+
 template<>
 struct NodeReader<SubscriptAst> : public BaseNodeReader<SubscriptAst>
 {
@@ -332,6 +343,28 @@ struct NodeReader<ImportAst> : public BaseNodeReader<ImportAst>
     READ_CHILD_LIST_IMPL(names)
 };
 
+template<>
+struct NodeReader<ImportFromAst> : public BaseNodeReader<ImportFromAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { names };
+    static auto constexpr ChildNames = { "names" };
+
+    using Attributes = enum { level, module };
+    static auto constexpr AttributeNames = { "name", "module" };
+
+    READ_CHILD_LIST_IMPL(names)
+
+    void readAttribute(AttributeTag<module>, QStringRef const& value) {
+        result->module = new Identifier(value.toString());
+    };
+
+    void readAttribute(AttributeTag<level>, QStringRef const& value) {
+        result->level = value.toInt();
+    }
+};
+
 template<>
 struct NodeReader<AliasAst> : public BaseNodeReader<AliasAst>
 {
@@ -359,3 +392,318 @@ struct NodeReader<AliasAst> : public BaseNodeReader<AliasAst>
         }
     }
 };
+
+template<>
+struct NodeReader<ListComprehensionAst> : public BaseNodeReader<ListComprehensionAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { element, generators };
+    static auto constexpr ChildNames = { "elt", "generators" };
+
+    READ_CHILD_IMPL(element)
+    READ_CHILD_LIST_IMPL(generators)
+};
+
+template<>
+struct NodeReader<SetComprehensionAst> : public BaseNodeReader<SetComprehensionAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { element, generators };
+    static auto constexpr ChildNames = { "elt", "generators" };
+
+    READ_CHILD_IMPL(element)
+    READ_CHILD_LIST_IMPL(generators)
+};
+
+template<>
+struct NodeReader<DictionaryComprehensionAst> : public BaseNodeReader<DictionaryComprehensionAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { key, value, generators };
+    static auto constexpr ChildNames = { "key", "value", "generators" };
+
+    READ_CHILD_IMPL(key)
+    READ_CHILD_IMPL(value)
+    READ_CHILD_LIST_IMPL(generators)
+};
+
+template<>
+struct NodeReader<ComprehensionAst> : public BaseNodeReader<ComprehensionAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { target, iterator, conditions };
+    static auto constexpr ChildNames = { "target", "iter", "ifs" };
+
+    READ_CHILD_IMPL(target)
+    READ_CHILD_IMPL(iterator)
+    READ_CHILD_LIST_IMPL(conditions)
+};
+
+template<>
+struct NodeReader<UnaryOperationAst> : public BaseNodeReader<UnaryOperationAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { operand };
+    static auto constexpr ChildNames = { "operand" };
+
+    using Attributes = enum { op };
+    static auto constexpr AttributeNames = {"op"};
+
+    READ_CHILD_IMPL(operand)
+
+    void readAttribute(AttributeTag<op>, QStringRef const& /*value*/) {
+        result->type = Ast::UnaryOperatorAdd; // FIXME
+    }
+};
+
+template<>
+struct NodeReader<LambdaAst> : public BaseNodeReader<LambdaAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { arguments, body };
+    static auto constexpr ChildNames = { "args", "body" };
+
+    READ_CHILD_IMPL(arguments)
+    READ_CHILD_IMPL(body)
+};
+
+template<>
+struct NodeReader<JoinedStringAst> : public BaseNodeReader<JoinedStringAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { values };
+    static auto constexpr ChildNames = { "values" };
+
+    READ_CHILD_LIST_IMPL(values)
+};
+
+template<>
+struct NodeReader<AugmentedAssignmentAst> : public BaseNodeReader<AugmentedAssignmentAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { target, value };
+    static auto constexpr ChildNames = { "target", "value" };
+
+    using Attributes = enum { op };
+    static auto constexpr AttributeNames = {"op"};
+
+    READ_CHILD_IMPL(target)
+    READ_CHILD_IMPL(value)
+
+    void readAttribute(AttributeTag<op>, QStringRef const& value) {
+        result->op = operatorType(value);
+    }
+};
+
+template<>
+struct NodeReader<DeleteAst> : public BaseNodeReader<DeleteAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { targets };
+    static auto constexpr ChildNames = { "targets" };
+
+    READ_CHILD_LIST_IMPL(targets)
+};
+
+template<>
+struct NodeReader<ForAst> : public BaseNodeReader<ForAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { target, iterator, body, orelse };
+    static auto constexpr ChildNames = { "target", "iter", "body", "orelse" };
+
+    READ_CHILD_IMPL(target)
+    READ_CHILD_IMPL(iterator)
+    READ_CHILD_LIST_IMPL(body)
+    READ_CHILD_LIST_IMPL(orelse)
+};
+
+template<>
+struct NodeReader<WhileAst> : public BaseNodeReader<WhileAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { condition, body, orelse };
+    static auto constexpr ChildNames = { "test", "body", "orelse" };
+
+    READ_CHILD_IMPL(condition)
+    READ_CHILD_LIST_IMPL(body)
+    READ_CHILD_LIST_IMPL(orelse)
+};
+
+template<>
+struct NodeReader<IfAst> : public BaseNodeReader<IfAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { condition, body, orelse };
+    static auto constexpr ChildNames = { "test", "body", "orelse" };
+
+    READ_CHILD_IMPL(condition)
+    READ_CHILD_LIST_IMPL(body)
+    READ_CHILD_LIST_IMPL(orelse)
+};
+
+template<>
+struct NodeReader<WithAst> : public BaseNodeReader<WithAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { body, items };
+    static auto constexpr ChildNames = { "items", "body" };
+
+    READ_CHILD_LIST_IMPL(body)
+    READ_CHILD_LIST_IMPL(items)
+};
+
+template<>
+struct NodeReader<WithItemAst> : public BaseNodeReader<WithItemAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { contextExpression, optionalVars };
+    static auto constexpr ChildNames = { "context_expr", "optional_vars" };
+
+    READ_CHILD_IMPL(contextExpression)
+    READ_CHILD_IMPL(optionalVars)
+};
+
+template<>
+struct NodeReader<CompareAst> : public BaseNodeReader<CompareAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { leftmostElement, operators, comparands };
+    static auto constexpr ChildNames = { "left", "ops", "comparators" };
+
+    READ_CHILD_IMPL(leftmostElement)
+    READ_CHILD_LIST_IMPL(comparands)
+
+    void readChild(ChildTag<operators>, Stream& s) {
+        while (s.readNextStartElement()) {
+            result->operators << comparisonOperatorType(s.name());
+            s.readNext();
+        }
+    }
+};
+
+template<>
+struct NodeReader<GeneratorExpressionAst> : public BaseNodeReader<GeneratorExpressionAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { element, generators };
+    static auto constexpr ChildNames = { "elt", "generators" };
+
+    READ_CHILD_IMPL(element)
+    READ_CHILD_LIST_IMPL(generators)
+};
+
+template<>
+struct NodeReader<RaiseAst> : public BaseNodeReader<RaiseAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { type };
+    static auto constexpr ChildNames = { "exc" };
+
+    READ_CHILD_IMPL(type)
+};
+
+template<>
+struct NodeReader<KeywordAst> : public BaseNodeReader<KeywordAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { value };
+    static auto constexpr ChildNames = { "value" };
+
+    using Attributes = enum { argumentName };
+    static auto constexpr AttributeNames = { "arg" };
+
+    READ_CHILD_IMPL(value)
+    READ_IDENTIFIER_IMPL(argumentName)
+};
+
+template<>
+struct NodeReader<StarredAst> : public BaseNodeReader<StarredAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { value };
+    static auto constexpr ChildNames = { "value" };
+
+    READ_CHILD_IMPL(value)
+};
+
+template<>
+struct NodeReader<TryAst> : public BaseNodeReader<TryAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { body, handlers, orelse, finally };
+    static auto constexpr ChildNames = { "body", "handlers", "orelse", "finalbody" };
+
+    READ_CHILD_LIST_IMPL(body)
+    READ_CHILD_LIST_IMPL(handlers)
+    READ_CHILD_LIST_IMPL(orelse)
+    READ_CHILD_LIST_IMPL(finally)
+};
+
+template<>
+struct NodeReader<ExceptionHandlerAst> : public BaseNodeReader<ExceptionHandlerAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Attributes = enum { name };
+    static auto constexpr AttributeNames = { "name" };
+
+    using Children = enum { type, body };
+    static auto constexpr ChildNames = { "type", "body" };
+
+    READ_CHILD_IMPL(type)
+    READ_CHILD_LIST_IMPL(body)
+    READ_IDENTIFIER_IMPL(name)
+};
+
+template<>
+struct NodeReader<FormattedValueAst> : public BaseNodeReader<FormattedValueAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { value, formatSpec };
+    static auto constexpr ChildNames = { "value", "format_spec" };
+
+    using Attributes = enum { conversion };
+    static auto constexpr AttributeNames = { "conversion" };
+
+    READ_CHILD_IMPL(value)
+    READ_CHILD_IMPL(formatSpec)
+
+    void readAttribute(AttributeTag<conversion>, QStringRef const& value) {
+        result->conversion = value.toInt();
+    }
+};
+
+template<>
+struct NodeReader<AnnotationAssignmentAst> : public BaseNodeReader<AnnotationAssignmentAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { target, value, annotation };
+    static auto constexpr ChildNames = { "target", "annotation", "value" };
+
+    READ_CHILD_IMPL(target)
+    READ_CHILD_IMPL(value)
+    READ_CHILD_IMPL(annotation)
+};
diff --git a/parser/astfromxml_detail/operators.h b/parser/astfromxml_detail/operators.h
index 68bdb910..c854f482 100644
--- a/parser/astfromxml_detail/operators.h
+++ b/parser/astfromxml_detail/operators.h
@@ -27,3 +27,7 @@ Ast::OperatorTypes operatorType(QStringRef const& name) {
 
     return Ast::OperatorInvalid;
 }
+
+Ast::ComparisonOperatorTypes comparisonOperatorType(QStringRef const& name) {
+    return Ast::ComparisonOperatorEquals; // FIXME
+}
diff --git a/parser/astfromxml_detail/typemap.h b/parser/astfromxml_detail/typemap.h
index b4cd9e3b..2a22eb30 100644
--- a/parser/astfromxml_detail/typemap.h
+++ b/parser/astfromxml_detail/typemap.h
@@ -19,7 +19,7 @@ QMap<QString, Ast::AstType> astTypes = {
     {QStringLiteral("Nonlocal"), Ast::NonlocalAstType},
     {QStringLiteral("arguments"), Ast::ArgumentsAstType},
     {QStringLiteral("arg"), Ast::ArgAstType},
-    {QStringLiteral("Keyword"), Ast::KeywordAstType},
+    {QStringLiteral("keyword"), Ast::KeywordAstType},
     {QStringLiteral("ClassDef"), Ast::ClassDefinitionAstType},
     {QStringLiteral("Return"), Ast::ReturnAstType},
     {QStringLiteral("Delete"), Ast::DeleteAstType},
@@ -36,30 +36,30 @@ QMap<QString, Ast::AstType> astTypes = {
     {QStringLiteral("Break"), Ast::BreakAstType},
     {QStringLiteral("Continue"), Ast::ContinueAstType},
     {QStringLiteral("Assertion"), Ast::AssertionAstType},
-    {QStringLiteral("AugmentedAssignment"), Ast::AugmentedAssignmentAstType},
-    {QStringLiteral("AnnotationAssignment"), Ast::AnnotationAssignmentAstType},
+    {QStringLiteral("AugAssign"), Ast::AugmentedAssignmentAstType},
+    {QStringLiteral("AnnAssign"), Ast::AnnotationAssignmentAstType},
     {QStringLiteral("Await"), Ast::AwaitAstType},
     {QStringLiteral("Name"), Ast::NameAstType},
     {QStringLiteral("NameConstant"), Ast::NameConstantAstType},
     {QStringLiteral("Constant"), Ast::ConstantAstType},
     {QStringLiteral("Call"), Ast::CallAstType},
     {QStringLiteral("Attribute"), Ast::AttributeAstType},
-    {QStringLiteral("DictionaryComprehension"), Ast::DictionaryComprehensionAstType},
+    {QStringLiteral("DictComp"), Ast::DictionaryComprehensionAstType},
     {QStringLiteral("BoolOp"), Ast::BooleanOperationAstType},
     {QStringLiteral("BinOp"), Ast::BinaryOperationAstType},
-    {QStringLiteral("UnaryOperation"), Ast::UnaryOperationAstType},
+    {QStringLiteral("UnaryOp"), Ast::UnaryOperationAstType},
     {QStringLiteral("Lambda"), Ast::LambdaAstType},
     {QStringLiteral("IfExpression"), Ast::IfExpressionAstType},
     {QStringLiteral("Dict"), Ast::DictAstType},
     {QStringLiteral("Set"), Ast::SetAstType},
-    {QStringLiteral("ListComprehension"), Ast::ListComprehensionAstType},
-    {QStringLiteral("SetComprehension"), Ast::SetComprehensionAstType},
-    {QStringLiteral("GeneratorExpression"), Ast::GeneratorExpressionAstType},
+    {QStringLiteral("ListComp"), Ast::ListComprehensionAstType},
+    {QStringLiteral("SetComp"), Ast::SetComprehensionAstType},
+    {QStringLiteral("GeneratorExp"), Ast::GeneratorExpressionAstType},
     {QStringLiteral("Yield"), Ast::YieldAstType},
     {QStringLiteral("Compare"), Ast::CompareAstType},
     {QStringLiteral("Number"), Ast::NumberAstType},
     {QStringLiteral("String"), Ast::StringAstType},
-    {QStringLiteral("JoinedString"), Ast::JoinedStringAstType},
+    {QStringLiteral("JoinedStr"), Ast::JoinedStringAstType},
     {QStringLiteral("FormattedValue"), Ast::FormattedValueAstType},
     {QStringLiteral("Bytes"), Ast::BytesAstType},
     {QStringLiteral("Subscript"), Ast::SubscriptAstType},
@@ -67,11 +67,11 @@ QMap<QString, Ast::AstType> astTypes = {
     {QStringLiteral("List"), Ast::ListAstType},
     {QStringLiteral("Tuple"), Ast::TupleAstType},
     {QStringLiteral("YieldFrom"), Ast::YieldFromAstType},
-    {QStringLiteral("Comprehension"), Ast::ComprehensionAstType},
+    {QStringLiteral("comprehension"), Ast::ComprehensionAstType},
     {QStringLiteral("Slice"), Ast::SliceAstType},
     {QStringLiteral("Ellipsis"), Ast::EllipsisAstType},
     {QStringLiteral("AssignmentExpression"), Ast::AssignmentExpressionAstType},
     {QStringLiteral("Module"), Ast::CodeAstType},
-    {QStringLiteral("ExceptionHandler"), Ast::ExceptionHandlerAstType},
+    {QStringLiteral("ExceptHandler"), Ast::ExceptionHandlerAstType},
     {QStringLiteral("alias"), Ast::AliasAstType},
 };
-- 
GitLab


From e1a648623619a986f4b1968579b705438f9bd0f6 Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Sat, 19 Mar 2022 12:27:48 +0100
Subject: [PATCH 16/29] implement Asssert, Break, Continue, Nonlocal

---
 parser/ast.cpp                             |  2 +-
 parser/ast.h                               |  1 +
 parser/astfromxml_detail/nodereader_impl.h | 40 ++++++++++++++++++++++
 parser/astfromxml_detail/typemap.h         |  2 +-
 4 files changed, 43 insertions(+), 2 deletions(-)

diff --git a/parser/ast.cpp b/parser/ast.cpp
index a8ffa0bf..793dab0e 100644
--- a/parser/ast.cpp
+++ b/parser/ast.cpp
@@ -30,7 +30,7 @@ ArgAst::ArgAst(Ast* parent): Ast(parent, Ast::ArgAstType), argumentName(nullptr)
 
 }
 
-AssertionAst::AssertionAst(Ast* parent): StatementAst(parent, Ast::AssertionAstType) 
+AssertionAst::AssertionAst(Ast* parent): StatementAst(parent, Ast::AssertionAstType), condition(nullptr), message(nullptr)
 {
     
 }
diff --git a/parser/ast.h b/parser/ast.h
index a53ab513..51187727 100644
--- a/parser/ast.h
+++ b/parser/ast.h
@@ -421,6 +421,7 @@ public:
 class KDEVPYTHONPARSER_EXPORT NonlocalAst : public StatementAst {
 public:
     NonlocalAst(Ast* parent);
+    QList<QString> names;
 };
 
 
diff --git a/parser/astfromxml_detail/nodereader_impl.h b/parser/astfromxml_detail/nodereader_impl.h
index ea137f1e..205ef061 100644
--- a/parser/astfromxml_detail/nodereader_impl.h
+++ b/parser/astfromxml_detail/nodereader_impl.h
@@ -707,3 +707,43 @@ struct NodeReader<AnnotationAssignmentAst> : public BaseNodeReader<AnnotationAss
     READ_CHILD_IMPL(value)
     READ_CHILD_IMPL(annotation)
 };
+
+template<>
+struct NodeReader<AssertionAst> : public BaseNodeReader<AssertionAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { condition, message };
+    static auto constexpr ChildNames = { "test", "msg" };
+
+    READ_CHILD_IMPL(condition)
+    READ_CHILD_IMPL(message)
+};
+
+template<>
+struct NodeReader<BreakAst> : public BaseNodeReader<BreakAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+};
+
+template<>
+struct NodeReader<ContinueAst> : public BaseNodeReader<ContinueAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+};
+
+template<>
+struct NodeReader<NonlocalAst> : public BaseNodeReader<NonlocalAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { names };
+    static auto constexpr ChildNames = { "names" };
+
+    void readChild(ChildTag<names>, Stream& s) {
+        while (s.readNextStartElement()) {
+            result->names << s.name().toString(); // FIXME this isn't serialized properly
+            s.readNext();
+        }
+    }
+};
diff --git a/parser/astfromxml_detail/typemap.h b/parser/astfromxml_detail/typemap.h
index 2a22eb30..58f74977 100644
--- a/parser/astfromxml_detail/typemap.h
+++ b/parser/astfromxml_detail/typemap.h
@@ -35,7 +35,7 @@ QMap<QString, Ast::AstType> astTypes = {
     {QStringLiteral("Global"), Ast::GlobalAstType},
     {QStringLiteral("Break"), Ast::BreakAstType},
     {QStringLiteral("Continue"), Ast::ContinueAstType},
-    {QStringLiteral("Assertion"), Ast::AssertionAstType},
+    {QStringLiteral("Assert"), Ast::AssertionAstType},
     {QStringLiteral("AugAssign"), Ast::AugmentedAssignmentAstType},
     {QStringLiteral("AnnAssign"), Ast::AnnotationAssignmentAstType},
     {QStringLiteral("Await"), Ast::AwaitAstType},
-- 
GitLab


From 5305023c5446b6f9725e74b66ddc404391221320 Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Sat, 19 Mar 2022 13:27:09 +0100
Subject: [PATCH 17/29] implement IfExpr, Global, Yield, AssignmentExpr

---
 parser/ast.h                               |  2 +-
 parser/astbuilder.cpp                      |  4 ++
 parser/astdefaultvisitor.cpp               |  5 +-
 parser/astfromxml_detail/nodereader_impl.h | 54 +++++++++++++++++++++-
 parser/astfromxml_detail/typemap.h         |  6 +--
 5 files changed, 65 insertions(+), 6 deletions(-)

diff --git a/parser/ast.h b/parser/ast.h
index 51187727..6c0f2763 100644
--- a/parser/ast.h
+++ b/parser/ast.h
@@ -421,7 +421,7 @@ public:
 class KDEVPYTHONPARSER_EXPORT NonlocalAst : public StatementAst {
 public:
     NonlocalAst(Ast* parent);
-    QList<QString> names;
+    QList<Identifier*> names;
 };
 
 
diff --git a/parser/astbuilder.cpp b/parser/astbuilder.cpp
index 26ad1736..9c73228d 100644
--- a/parser/astbuilder.cpp
+++ b/parser/astbuilder.cpp
@@ -91,6 +91,7 @@ Python::CodeAst* __testing_AstFromString(QString const& string) {
     auto const error = p.readAllStandardError();
     if (!error.isEmpty()) {
         qWarning() << "error running parser:" << QString::fromUtf8(error);
+        return nullptr;
     }
     qDebug() << "using xml:" << xml;
     return astFromXml(xml);
@@ -105,6 +106,9 @@ CodeAst::Ptr AstBuilder::parse(const QUrl& filename, QString &contents)
     contents.append('\n');
 
     auto* ast = __testing_AstFromString(contents);
+    if (!ast)
+        return nullptr;
+
     ast->name = new Identifier(filename.fileName());
 
 #if 0
diff --git a/parser/astdefaultvisitor.cpp b/parser/astdefaultvisitor.cpp
index baf7557b..530d2db6 100644
--- a/parser/astdefaultvisitor.cpp
+++ b/parser/astdefaultvisitor.cpp
@@ -25,7 +25,6 @@ AstDefaultVisitor::~AstDefaultVisitor() { }
 // note that Identifier is not a node in this Ast
 void AstDefaultVisitor::visitNameConstant(NameConstantAst* node) { Q_UNUSED(node); }
 void AstDefaultVisitor::visitPass(PassAst* node) { Q_UNUSED(node); }
-void AstDefaultVisitor::visitNonlocal(NonlocalAst* node) { Q_UNUSED(node); }
 void AstDefaultVisitor::visitBreak(BreakAst* node) { Q_UNUSED(node); }
 void AstDefaultVisitor::visitContinue(ContinueAst* node) { Q_UNUSED(node); }
 void AstDefaultVisitor::visitEllipsis(EllipsisAst* node) { Q_UNUSED(node); }
@@ -35,6 +34,10 @@ void AstDefaultVisitor::visitBytes(BytesAst* node) { Q_UNUSED(node); }
 void AstDefaultVisitor::visitIdentifier(Identifier* node) { Q_UNUSED(node); }
 void AstDefaultVisitor::visitConstant(ConstantAst* node) { Q_UNUSED(node); }
 
+void AstDefaultVisitor::visitNonlocal(NonlocalAst* node) {
+    visitNodeList(node->names);
+}
+
 void AstDefaultVisitor::visitJoinedString(JoinedStringAst* node) {
 //TODO: Fix range/context/??? bugs, then re-enable this.
     Q_UNUSED(node);
diff --git a/parser/astfromxml_detail/nodereader_impl.h b/parser/astfromxml_detail/nodereader_impl.h
index 205ef061..6e51cb66 100644
--- a/parser/astfromxml_detail/nodereader_impl.h
+++ b/parser/astfromxml_detail/nodereader_impl.h
@@ -554,6 +554,19 @@ struct NodeReader<IfAst> : public BaseNodeReader<IfAst>
     READ_CHILD_LIST_IMPL(orelse)
 };
 
+template<>
+struct NodeReader<IfExpressionAst> : public BaseNodeReader<IfExpressionAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { condition, body, orelse };
+    static auto constexpr ChildNames = { "test", "body", "orelse" };
+
+    READ_CHILD_IMPL(condition)
+    READ_CHILD_IMPL(body)
+    READ_CHILD_IMPL(orelse)
+};
+
 template<>
 struct NodeReader<WithAst> : public BaseNodeReader<WithAst>
 {
@@ -742,8 +755,47 @@ struct NodeReader<NonlocalAst> : public BaseNodeReader<NonlocalAst>
 
     void readChild(ChildTag<names>, Stream& s) {
         while (s.readNextStartElement()) {
-            result->names << s.name().toString(); // FIXME this isn't serialized properly
+            result->names << new Identifier(s.name().toString()); // FIXME this isn't serialized properly
+            s.readNext();
+        }
+    }
+};
+
+template<>
+struct NodeReader<GlobalAst> : public BaseNodeReader<GlobalAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { names };
+    static auto constexpr ChildNames = { "names" };
+
+    void readChild(ChildTag<names>, Stream& s) {
+        while (s.readNextStartElement()) {
+            result->names << new Identifier(s.name().toString()); // FIXME this isn't serialized properly
             s.readNext();
         }
     }
 };
+
+template<>
+struct NodeReader<YieldAst> : public BaseNodeReader<YieldAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { value };
+    static auto constexpr ChildNames = { "value" };
+
+    READ_CHILD_IMPL(value)
+};
+
+template<>
+struct NodeReader<AssignmentExpressionAst> : public BaseNodeReader<AssignmentExpressionAst>
+{
+    using BaseNodeReader::BaseNodeReader;
+
+    using Children = enum { target, value };
+    static auto constexpr ChildNames = { "target", "value" };
+
+    READ_CHILD_IMPL(target)
+    READ_CHILD_IMPL(value)
+};
diff --git a/parser/astfromxml_detail/typemap.h b/parser/astfromxml_detail/typemap.h
index 58f74977..d6324073 100644
--- a/parser/astfromxml_detail/typemap.h
+++ b/parser/astfromxml_detail/typemap.h
@@ -27,7 +27,7 @@ QMap<QString, Ast::AstType> astTypes = {
     {QStringLiteral("While"), Ast::WhileAstType},
     {QStringLiteral("If"), Ast::IfAstType},
     {QStringLiteral("With"), Ast::WithAstType},
-    {QStringLiteral("WithItem"), Ast::WithItemAstType},
+    {QStringLiteral("withitem"), Ast::WithItemAstType},
     {QStringLiteral("Raise"), Ast::RaiseAstType},
     {QStringLiteral("Try"), Ast::TryAstType},
     {QStringLiteral("Import"), Ast::ImportAstType},
@@ -49,7 +49,7 @@ QMap<QString, Ast::AstType> astTypes = {
     {QStringLiteral("BinOp"), Ast::BinaryOperationAstType},
     {QStringLiteral("UnaryOp"), Ast::UnaryOperationAstType},
     {QStringLiteral("Lambda"), Ast::LambdaAstType},
-    {QStringLiteral("IfExpression"), Ast::IfExpressionAstType},
+    {QStringLiteral("IfExp"), Ast::IfExpressionAstType},
     {QStringLiteral("Dict"), Ast::DictAstType},
     {QStringLiteral("Set"), Ast::SetAstType},
     {QStringLiteral("ListComp"), Ast::ListComprehensionAstType},
@@ -70,7 +70,7 @@ QMap<QString, Ast::AstType> astTypes = {
     {QStringLiteral("comprehension"), Ast::ComprehensionAstType},
     {QStringLiteral("Slice"), Ast::SliceAstType},
     {QStringLiteral("Ellipsis"), Ast::EllipsisAstType},
-    {QStringLiteral("AssignmentExpression"), Ast::AssignmentExpressionAstType},
+    {QStringLiteral("NamedExpr"), Ast::AssignmentExpressionAstType},
     {QStringLiteral("Module"), Ast::CodeAstType},
     {QStringLiteral("ExceptHandler"), Ast::ExceptionHandlerAstType},
     {QStringLiteral("alias"), Ast::AliasAstType},
-- 
GitLab


From 68e1d62cf6cfcf4ca88da4ae075f0f383a8a2ffc Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Sat, 19 Mar 2022 16:13:28 +0100
Subject: [PATCH 18/29] fix bytes and various operators

---
 duchain/declarationbuilder.cpp             |  2 --
 duchain/expressionvisitor.cpp              | 27 ++++++++++++++------
 parser/ast.h                               |  2 +-
 parser/ast2xml.py                          |  4 +--
 parser/astfromxml_detail/nodereader_impl.h | 17 ++++++++++---
 parser/astfromxml_detail/operators.h       | 29 +++++++++++++++++++++-
 6 files changed, 64 insertions(+), 17 deletions(-)

diff --git a/duchain/declarationbuilder.cpp b/duchain/declarationbuilder.cpp
index c1678d52..64b68c36 100644
--- a/duchain/declarationbuilder.cpp
+++ b/duchain/declarationbuilder.cpp
@@ -1850,10 +1850,8 @@ void DeclarationBuilder::visitString(StringAst* node) {
 
 void DeclarationBuilder::visitConstant(ConstantAst* node) {
     if ( std::holds_alternative<QString>(node->value) ) {
-        qDebug() << "visiting string constant" << node->parent->astType;
         if ( node->parent && node->parent->astType == Ast::ExpressionAstType ) {
             m_lastComment = std::get<QString>(node->value);
-            qDebug() << "setting last comment" << m_lastComment;
         }
     }
     DeclarationBuilderBase::visitConstant(node);
diff --git a/duchain/expressionvisitor.cpp b/duchain/expressionvisitor.cpp
index d32bdcb0..85d1d440 100644
--- a/duchain/expressionvisitor.cpp
+++ b/duchain/expressionvisitor.cpp
@@ -304,19 +304,26 @@ long integerValue(ExpressionAst* node, long wrapTo=0) {
             invert = true;
         }
     }
+    auto value = LONG_MIN;
     if ( node->astType == Ast::NumberAstType ) {
         auto number = static_cast<NumberAst*>(node);
         if ( number->isInt ) {
-            // Clamp in case of `a[-9999999:9999999]` or similar.
-            // -1 is just as out-of-range as -99999999, but doesn't cause a huge loop.
-            long upperBound = wrapTo ? wrapTo : LONG_MAX;
-            if (invert) {
-                return qBound(-1L, wrapTo - number->value, upperBound);
-            }
-            return qBound(-1L, number->value, upperBound);
+            value = number->value;
+        }
+    }
+    if ( node->astType == Ast::ConstantAstType ) {
+        if (auto* intValue = std::get_if<int>(&static_cast<ConstantAst*>(node)->value)) {
+            value = *intValue;
         }
     }
-    return LONG_MIN;
+
+    // Clamp in case of `a[-9999999:9999999]` or similar.
+    // -1 is just as out-of-range as -99999999, but doesn't cause a huge loop.
+    long upperBound = wrapTo ? wrapTo : LONG_MAX;
+    if ( invert ) {
+        return qBound(-1L, wrapTo - value, upperBound);
+    }
+    return qBound(-1L, value, upperBound);
 }
 
 void ExpressionVisitor::visitSubscript(SubscriptAst* node)
@@ -650,6 +657,10 @@ void ExpressionVisitor::visitConstant(ConstantAst* node)
     else if (std::holds_alternative<float>(node->value)) {
         return encounter(typeObjectForIntegralType<StructureType>("float"));
     }
+    else if (std::holds_alternative<QByteArray>(node->value)) {
+        return encounter(typeObjectForIntegralType<StructureType>("bytes"));
+    }
+    encounterUnknown();
 }
 
 void ExpressionVisitor::visitName(Python::NameAst* node)
diff --git a/parser/ast.h b/parser/ast.h
index 6c0f2763..0bc892f1 100644
--- a/parser/ast.h
+++ b/parser/ast.h
@@ -584,7 +584,7 @@ public:
 class KDEVPYTHONPARSER_EXPORT ConstantAst : public ExpressionAst {
 public:
     ConstantAst(Ast* parent);
-    std::variant<int, float, QString> value;
+    std::variant<int, float, QString, QByteArray> value;
     bool usedAsComment;
 };
 
diff --git a/parser/ast2xml.py b/parser/ast2xml.py
index e8dbed04..8da503a9 100644
--- a/parser/ast2xml.py
+++ b/parser/ast2xml.py
@@ -31,8 +31,8 @@ class ASTSerializer(ast.NodeVisitor):
             attrs["op"] = type(node.op).__name__
         if name == "UnaryOp":
             attrs["op"] = type(node.op).__name__
-        plain_attrs = {k: str(v) for k, v in attrs.items() if type(v) in plain_types}
-        non_plain_attrs = {k: v for k, v in attrs.items() if type(v) not in plain_types}
+        plain_attrs = {k: str(v) for k, v in attrs.items() if type(v) in plain_types and v is not None}
+        non_plain_attrs = {k: v for k, v in attrs.items() if type(v) not in plain_types and v is not None}
         with xf.element(name, **plain_attrs) as elem:
             for attr, attr_val in non_plain_attrs.items():
                 if attr == "ctx":
diff --git a/parser/astfromxml_detail/nodereader_impl.h b/parser/astfromxml_detail/nodereader_impl.h
index 6e51cb66..9b769b7a 100644
--- a/parser/astfromxml_detail/nodereader_impl.h
+++ b/parser/astfromxml_detail/nodereader_impl.h
@@ -19,7 +19,8 @@
         result->name = new Identifier(value.toString()); \
     } \
     ~NodeReader() { \
-        result->name->rangeFrom(result); \
+        if (result->name) \
+            result->name->rangeFrom(result); \
     }
 #define IGNORE_CHILD(name) \
     void readChild(ChildTag<name>, Stream& s) { [[maybe_unused]] Ast* r; singleFromXml(result, r, s); }
@@ -178,6 +179,9 @@ struct NodeReader<ConstantAst> : public BaseNodeReader<ConstantAst>
         else if (value == "int") {
             result->value = std::get<QString>(result->value).toInt();
         }
+        else if (value == "bytes") {
+            result->value = std::get<QString>(result->value).toUtf8();
+        }
     }
 };
 
@@ -298,10 +302,17 @@ struct NodeReader<BooleanOperationAst> : public BaseNodeReader<BooleanOperationA
 {
     using BaseNodeReader::BaseNodeReader;
 
+    using Attributes = enum { op };
+    static auto constexpr AttributeNames = { "op" };
+
     using Children = enum { values };
     static auto constexpr ChildNames = { "values" };
 
     READ_CHILD_LIST_IMPL(values)
+
+    void readAttribute(AttributeTag<op>, QStringRef const& value) {
+        result->type = booleanOperatorType(value);
+    }
 };
 
 template<>
@@ -456,8 +467,8 @@ struct NodeReader<UnaryOperationAst> : public BaseNodeReader<UnaryOperationAst>
 
     READ_CHILD_IMPL(operand)
 
-    void readAttribute(AttributeTag<op>, QStringRef const& /*value*/) {
-        result->type = Ast::UnaryOperatorAdd; // FIXME
+    void readAttribute(AttributeTag<op>, QStringRef const& value) {
+        result->type = unaryOperatorType(value);
     }
 };
 
diff --git a/parser/astfromxml_detail/operators.h b/parser/astfromxml_detail/operators.h
index c854f482..01c52ba7 100644
--- a/parser/astfromxml_detail/operators.h
+++ b/parser/astfromxml_detail/operators.h
@@ -29,5 +29,32 @@ Ast::OperatorTypes operatorType(QStringRef const& name) {
 }
 
 Ast::ComparisonOperatorTypes comparisonOperatorType(QStringRef const& name) {
-    return Ast::ComparisonOperatorEquals; // FIXME
+    if (name == "Eq") return Ast::ComparisonOperatorEquals;
+    if (name == "NotEq") return Ast::ComparisonOperatorNotEquals;
+    if (name == "Lt") return Ast::ComparisonOperatorLessThan;
+    if (name == "LtE") return Ast::ComparisonOperatorLessThanEqual;
+    if (name == "Gt") return Ast::ComparisonOperatorGreaterThan;
+    if (name == "GtE") return Ast::ComparisonOperatorGreaterThanEqual;
+    if (name == "Is") return Ast::ComparisonOperatorIs;
+    if (name == "IsNot") return Ast::ComparisonOperatorIsNot;
+    if (name == "In") return Ast::ComparisonOperatorIn;
+    if (name == "NotIn") return Ast::ComparisonOperatorNotIn;
+
+    return Ast::ComparisonOperatorInvalid;
+}
+
+Ast::UnaryOperatorTypes unaryOperatorType(QStringRef const& name) {
+    if (name == "Invert") return Ast::UnaryOperatorInvert;
+    if (name == "Not") return Ast::UnaryOperatorNot;
+    if (name == "UAdd") return Ast::UnaryOperatorAdd;
+    if (name == "USub") return Ast::UnaryOperatorSub;
+
+    return Ast::UnaryOperatorInvalid;
+}
+
+Ast::BooleanOperationTypes booleanOperatorType(QStringRef const& name) {
+    if (name == "And") return Ast::BooleanAnd;
+    if (name == "Or") return Ast::BooleanOr;
+
+    return Ast::BooleanInvalidOperation;
 }
-- 
GitLab


From 335317f7573ab4832ebd2360c91a7a81d0df07dd Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Sun, 20 Mar 2022 12:00:13 +0100
Subject: [PATCH 19/29] fix boolean type

---
 duchain/expressionvisitor.cpp              | 20 ++++++--------------
 duchain/expressionvisitor.h                |  2 --
 parser/ast.h                               |  2 +-
 parser/astfromxml_detail/nodereader_impl.h |  3 +++
 4 files changed, 10 insertions(+), 17 deletions(-)

diff --git a/duchain/expressionvisitor.cpp b/duchain/expressionvisitor.cpp
index 85d1d440..29c22e78 100644
--- a/duchain/expressionvisitor.cpp
+++ b/duchain/expressionvisitor.cpp
@@ -38,7 +38,7 @@ using namespace KTextEditor;
 
 namespace Python {
 
-QHash<NameConstantAst::NameConstantTypes, KDevelop::AbstractType::Ptr> ExpressionVisitor::m_defaultTypes;
+static KDevelop::AbstractType::Ptr booleanType;
 
 AbstractType::Ptr ExpressionVisitor::encounterPreprocess(AbstractType::Ptr type)
 {
@@ -48,10 +48,8 @@ AbstractType::Ptr ExpressionVisitor::encounterPreprocess(AbstractType::Ptr type)
 ExpressionVisitor::ExpressionVisitor(const DUContext* ctx)
     : DynamicLanguageExpressionVisitor(ctx)
 {
-    if ( m_defaultTypes.isEmpty() ) {
-        m_defaultTypes.insert(NameConstantAst::True, AbstractType::Ptr(new IntegralType(IntegralType::TypeBoolean)));
-        m_defaultTypes.insert(NameConstantAst::False, AbstractType::Ptr(new IntegralType(IntegralType::TypeBoolean)));
-        m_defaultTypes.insert(NameConstantAst::None, AbstractType::Ptr(new NoneType()));
+    if ( !booleanType ) {
+        booleanType = AbstractType::Ptr(new IntegralType(IntegralType::TypeBoolean));
     }
     Q_ASSERT(context());
     Q_ASSERT(context()->topContext());
@@ -636,15 +634,6 @@ void ExpressionVisitor::addUnknownName(const QString& name)
     }
 }
 
-void ExpressionVisitor::visitNameConstant(NameConstantAst* node)
-{
-    // handles "True", "False", "None"
-    auto defId = m_defaultTypes.constFind(node->value);
-    if ( defId != m_defaultTypes.constEnd() ) {
-        return encounter(*defId);
-    }
-}
-
 void ExpressionVisitor::visitConstant(ConstantAst* node)
 {
     DUChainReadLocker lock;
@@ -660,6 +649,9 @@ void ExpressionVisitor::visitConstant(ConstantAst* node)
     else if (std::holds_alternative<QByteArray>(node->value)) {
         return encounter(typeObjectForIntegralType<StructureType>("bytes"));
     }
+    else if (std::holds_alternative<bool>(node->value)) {
+        return encounter(booleanType);
+    }
     encounterUnknown();
 }
 
diff --git a/duchain/expressionvisitor.h b/duchain/expressionvisitor.h
index 6ad085ad..df68a41f 100644
--- a/duchain/expressionvisitor.h
+++ b/duchain/expressionvisitor.h
@@ -68,7 +68,6 @@ public:
     void visitDictionaryComprehension(DictionaryComprehensionAst* node) override;
     void visitSetComprehension(SetComprehensionAst* node) override;
     void visitIfExpression(IfExpressionAst* node) override;
-    void visitNameConstant(NameConstantAst* node) override;
     void visitConstant(ConstantAst* node) override;
     void visitAssignmentExpression(AssignmentExpressionAst* node) override;
 
@@ -136,7 +135,6 @@ private:
     /// used by code completion to detect unknown NameAst elements in expressions
     bool m_reportUnknownNames = false;
     CursorInRevision m_scanUntilCursor = CursorInRevision::invalid();
-    static QHash<NameConstantAst::NameConstantTypes, KDevelop::AbstractType::Ptr> m_defaultTypes;
     QSet<QString> m_unknownNames;
 };
 
diff --git a/parser/ast.h b/parser/ast.h
index 0bc892f1..4ac908f2 100644
--- a/parser/ast.h
+++ b/parser/ast.h
@@ -584,7 +584,7 @@ public:
 class KDEVPYTHONPARSER_EXPORT ConstantAst : public ExpressionAst {
 public:
     ConstantAst(Ast* parent);
-    std::variant<int, float, QString, QByteArray> value;
+    std::variant<int, float, QString, QByteArray, bool> value;
     bool usedAsComment;
 };
 
diff --git a/parser/astfromxml_detail/nodereader_impl.h b/parser/astfromxml_detail/nodereader_impl.h
index 9b769b7a..5ab75a85 100644
--- a/parser/astfromxml_detail/nodereader_impl.h
+++ b/parser/astfromxml_detail/nodereader_impl.h
@@ -182,6 +182,9 @@ struct NodeReader<ConstantAst> : public BaseNodeReader<ConstantAst>
         else if (value == "bytes") {
             result->value = std::get<QString>(result->value).toUtf8();
         }
+        else if (value == "bool") {
+            result->value = std::get<QString>(result->value) == "True" ? true : false;
+        }
     }
 };
 
-- 
GitLab


From 27d17c0ab6caf0cf707afaa6ee13713f8fdb4b4c Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Sun, 20 Mar 2022 12:01:33 +0100
Subject: [PATCH 20/29] fix test

---
 duchain/tests/pyduchaintest.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/duchain/tests/pyduchaintest.cpp b/duchain/tests/pyduchaintest.cpp
index 6b93d87f..7d19357d 100644
--- a/duchain/tests/pyduchaintest.cpp
+++ b/duchain/tests/pyduchaintest.cpp
@@ -836,7 +836,7 @@ void PyDUChainTest::testTypes_data()
 
 #if PYTHON_VERSION >= QT_VERSION_CHECK(3, 6, 0)
     QTest::newRow("annotate_decl") << "checkme: int" << "int";
-    QTest::newRow("annotate_assign") << "checkme: int = 3.5" << "unsure (float, int)";
+    QTest::newRow("annotate_assign") << "checkme: int = 3.5" << "unsure (int, float)";
 #endif
     QTest::newRow("listtype") << "checkme = []" << "list";
     QTest::newRow("listtype_func") << "checkme = list()" << "list";
-- 
GitLab


From fed01ab4aa6c83a96bf4bd2c63702a80cbbb3955 Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Sun, 20 Mar 2022 16:10:51 +0100
Subject: [PATCH 21/29] fix a = {**b} type dictionary assignment

---
 duchain/expressionvisitor.cpp   | 15 +++++++++++++--
 duchain/tests/pyduchaintest.cpp |  1 +
 2 files changed, 14 insertions(+), 2 deletions(-)

diff --git a/duchain/expressionvisitor.cpp b/duchain/expressionvisitor.cpp
index 29c22e78..d92af1e3 100644
--- a/duchain/expressionvisitor.cpp
+++ b/duchain/expressionvisitor.cpp
@@ -559,11 +559,12 @@ void ExpressionVisitor::visitDict(DictAst* node)
     DUChainReadLocker lock;
     auto type = typeObjectForIntegralType<MapType>("dict");
     lock.unlock();
+
     ExpressionVisitor contentVisitor(this);
     ExpressionVisitor keyVisitor(this);
     if ( type ) {
-        Q_ASSERT(node->keys.length() == node->values.length());
-        for ( int ii = 0; ii < node->values.length(); ++ii ) {
+        Q_ASSERT(node->keys.length() <= node->values.length());
+        for ( int ii = 0; ii < node->keys.length(); ++ii ) {
             contentVisitor.visitNode(node->values.at(ii));
             if ( node->keys.at(ii) ) {
                 type->addContentType<Python::UnsureType>(contentVisitor.lastType());
@@ -576,6 +577,16 @@ void ExpressionVisitor::visitDict(DictAst* node)
                 type->addKeyType<Python::UnsureType>(unpackedType->keyType().abstractType());
             }
         }
+
+        // Now, deal with a = {3:5, **b} the **b part(s)
+        for (int valueIndex = node->keys.length(); valueIndex < node->values.length(); valueIndex++) {
+            ExpressionVisitor starredVisitor(this);
+            starredVisitor.visitNode(node->values.at(valueIndex));
+            if ( auto map = starredVisitor.lastType().cast<MapType>() ) {
+                type->addKeyType<Python::UnsureType>(map->keyType().abstractType());
+                type->addContentType<Python::UnsureType>(map->contentType().abstractType());
+            }
+        }
     }
     encounter(AbstractType::Ptr::staticCast(type));
 }
diff --git a/duchain/tests/pyduchaintest.cpp b/duchain/tests/pyduchaintest.cpp
index 7d19357d..3d41dcc9 100644
--- a/duchain/tests/pyduchaintest.cpp
+++ b/duchain/tests/pyduchaintest.cpp
@@ -1681,6 +1681,7 @@ void PyDUChainTest::testContainerTypes_data()
 #if PYTHON_VERSION >= QT_VERSION_CHECK(3, 5, 0)
     QTest::newRow("set_from_unpacked") << "foo = [1.3]\ncheckme = {1, *foo, 3}" << "unsure (int, float)" << false;
     QTest::newRow("dict_from_unpacked") << "checkme = {**{'a': 1}}" << "dict of str : int" << true;
+    QTest::newRow("dict_from_unpacked_multi") << "checkme = {**{'a': 1}, **{'b': 1.5}}" << "dict of str : unsure (int, float)" << true;
     QTest::newRow("dict_from_varied") << "checkme = {**{'a': 1}, 1: 1.5}" <<
                                          "dict of unsure (str, int) : unsure (int, float)" << true;
 #endif
-- 
GitLab


From 3dc588d2c66e83ab3278b2cde5bdd9329b640c32 Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Sun, 20 Mar 2022 17:37:03 +0100
Subject: [PATCH 22/29] invoke python code from C api, not via QProcess

---
 parser/CMakeLists.txt  |   2 +
 parser/ast2xml.py      |  39 +++++++++----
 parser/astbuilder.cpp  | 122 +++++++----------------------------------
 parser/astfromxml.cpp  |   4 ++
 parser/python_header.h |   9 +--
 parser/pythonrun.cpp   | 114 ++++++++++++++++++++++++++++++++++++++
 parser/pythonrun.h     |  24 ++++++++
 parser/resources.qrc   |   6 ++
 8 files changed, 198 insertions(+), 122 deletions(-)
 create mode 100644 parser/pythonrun.cpp
 create mode 100644 parser/pythonrun.h
 create mode 100644 parser/resources.qrc

diff --git a/parser/CMakeLists.txt b/parser/CMakeLists.txt
index 3573b6d1..d0bde920 100644
--- a/parser/CMakeLists.txt
+++ b/parser/CMakeLists.txt
@@ -8,6 +8,8 @@ set(parser_STAT_SRCS
     cythonsyntaxremover.cpp
     rangefixvisitor.cpp
     astfromxml.cpp
+    pythonrun.cpp
+    resources.qrc
 )
 ecm_qt_declare_logging_category(parser_STAT_SRCS
     HEADER parserdebug.h
diff --git a/parser/ast2xml.py b/parser/ast2xml.py
index 8da503a9..67f10f1b 100644
--- a/parser/ast2xml.py
+++ b/parser/ast2xml.py
@@ -33,12 +33,12 @@ class ASTSerializer(ast.NodeVisitor):
             attrs["op"] = type(node.op).__name__
         plain_attrs = {k: str(v) for k, v in attrs.items() if type(v) in plain_types and v is not None}
         non_plain_attrs = {k: v for k, v in attrs.items() if type(v) not in plain_types and v is not None}
-        with xf.element(name, **plain_attrs) as elem:
+        with self.xf.element(name, **plain_attrs) as elem:
             for attr, attr_val in non_plain_attrs.items():
                 if attr == "ctx":
                     continue
                 if type(attr_val) == list_type:
-                    with xf.element(attr) as list_name_elem:
+                    with self.xf.element(attr) as list_name_elem:
                         for entry in attr_val:
                             self.generic_visit(entry)
                 elif attr_val is None:
@@ -46,20 +46,35 @@ class ASTSerializer(ast.NodeVisitor):
                 elif type(attr_val).__name__ == "ellipsis":
                     pass
                 elif issubclass(type(attr_val), ast.AST):
-                    with xf.element(attr) as name_elem:
+                    with self.xf.element(attr) as name_elem:
                         self.generic_visit(attr_val)
                 else:
                     print(attr, attr_val, type(attr_val))
                     assert False
 
-with open(sys.argv[1], "r") as fp:
-    text = fp.read()
+def doParse(code):
+    try:
+        m = ast.parse(code)
+        m = ast.fix_missing_locations(m)
+    except SyntaxError as syntaxError:
+        return f"""SyntaxError
+{syntaxError.filename}
+{syntaxError.lineno}
+{syntaxError.offset}
+{syntaxError.msg}
+"""
+    except Exception as err:
+        return f"InternalError: {str(err)}"
 
-m = ast.parse(text)
-m = ast.fix_missing_locations(m)
+    f = BytesIO()
+    with etree.xmlfile(f) as xf:
+        v = ASTSerializer(xf)
+        v.visit(m)
 
-f = BytesIO()
-with etree.xmlfile(f) as xf:
-    v = ASTSerializer(xf)
-    v.visit(m)
-print(f.getvalue().decode('utf-8'))
+    return f.getvalue().decode('utf-8')
+
+if __name__ == "__main__":
+    with open(sys.argv[1], "r") as fp:
+        text = fp.read()
+
+    print(doParse(text))
diff --git a/parser/astbuilder.cpp b/parser/astbuilder.cpp
index 9c73228d..1901f719 100644
--- a/parser/astbuilder.cpp
+++ b/parser/astbuilder.cpp
@@ -14,11 +14,11 @@
 
 #include <memory>
 
-#include "python_header.h"
 #include "astdefaultvisitor.h"
 #include "cythonsyntaxremover.h"
 #include "rangefixvisitor.h"
 #include "astfromxml.h"
+#include "pythonrun.h"
 
 #include <QDebug>
 #include <QTemporaryFile>
@@ -29,112 +29,24 @@ using namespace KDevelop;
 
 namespace Python
 {
-#include "generated.h"
-
-QMutex AstBuilder::pyInitLock;
-
-QString PyUnicodeObjectToQString(PyObject* obj) {
-    auto pyObjectCleanup = [](PyObject* o) { if (o) Py_DECREF(o); };
-    const auto strOwner = std::unique_ptr<PyObject, decltype(pyObjectCleanup)>(PyObject_Str(obj), pyObjectCleanup);
-    const auto str = strOwner.get();
-    if (PyUnicode_READY(str) < 0) {
-        qWarning("PyUnicode_READY(%p) returned false!", (void*)str);
-        return QString();
-    }
-    const auto length = PyUnicode_GET_LENGTH(str);
-    switch(PyUnicode_KIND(str)) {
-        case PyUnicode_1BYTE_KIND:
-            return QString::fromLatin1((const char*)PyUnicode_1BYTE_DATA(str), length);
-        case PyUnicode_2BYTE_KIND:
-            return QString::fromUtf16(PyUnicode_2BYTE_DATA(str), length);
-        case PyUnicode_4BYTE_KIND:
-            return QString::fromUcs4(PyUnicode_4BYTE_DATA(str), length);
-    }
-    qCritical("PyUnicode_KIND(%p) returned an unexpected value, this should not happen!", (void*)str);
-    Q_UNREACHABLE();
-}
-
-namespace {
-
-struct PythonInitializer : private QMutexLocker {
-    PythonInitializer(QMutex& pyInitLock):
-        QMutexLocker(&pyInitLock), arena(nullptr)
-    {
-            Py_InitializeEx(0);
-            Q_ASSERT(Py_IsInitialized());
-
-            arena = _PyArena_New();
-            Q_ASSERT(arena); // out of memory
-    }
-    ~PythonInitializer()
-    {
-        if (arena)
-            _PyArena_Free(arena);
-        if (Py_IsInitialized())
-            Py_Finalize();
-    }
-    PyArena* arena;
-};
-
-Python::CodeAst* __testing_AstFromString(QString const& string) {
-    QTemporaryFile f;
-    f.open();
-    f.write(string.toUtf8());
-    qDebug() << "written:" << string;
-    f.close();
-    QProcess p;
-    p.setProgram("/usr/bin/env");
-    p.setArguments({"python", "../parser/ast2xml.py", f.fileName()});
-    p.start();
-    p.waitForFinished(5000);
-    auto const xml = p.readAllStandardOutput();
-    auto const error = p.readAllStandardError();
-    if (!error.isEmpty()) {
-        qWarning() << "error running parser:" << QString::fromUtf8(error);
-        return nullptr;
-    }
-    qDebug() << "using xml:" << xml;
-    return astFromXml(xml);
-}
-
-}
 
 CodeAst::Ptr AstBuilder::parse(const QUrl& filename, QString &contents)
 {
     qCDebug(KDEV_PYTHON_PARSER) << " ====> AST     ====>     building abstract syntax tree for " << filename.path();
-    
+
     contents.append('\n');
 
-    auto* ast = __testing_AstFromString(contents);
-    if (!ast)
+    auto result = parsePythonCode(contents.toUtf8());
+    if (!result) {
+        qCWarning(KDEV_PYTHON_PARSER) << "Internal error while parsing python code";
         return nullptr;
+    }
 
-    ast->name = new Identifier(filename.fileName());
-
-#if 0
-    if ( ! syntaxtree ) {
+    if ( result->error ) {
         qCDebug(KDEV_PYTHON_PARSER) << " ====< parse error, trying to fix";
 
-        PyObject *exception, *value, *backtrace;
-        PyErr_Fetch(&exception, &value, &backtrace);
-        qCDebug(KDEV_PYTHON_PARSER) << "Error objects: " << exception << value << backtrace;
-
-        if ( ! value ) {
-            qCWarning(KDEV_PYTHON_PARSER) << "Internal parser error: exception value is null, aborting";
-            return CodeAst::Ptr();
-        }
-        PyErr_NormalizeException(&exception, &value, &backtrace);
-
-        if ( ! PyObject_IsInstance(value, PyExc_SyntaxError) ) {
-            qCWarning(KDEV_PYTHON_PARSER) << "Exception was not a SyntaxError, aborting";
-            return CodeAst::Ptr();
-        }
-        PyObject* errorMessage_str = PyObject_GetAttrString(value, "msg");
-        PyObject* linenoobj = PyObject_GetAttrString(value, "lineno");
-        PyObject* colnoobj = PyObject_GetAttrString(value, "offset");
-
-        int lineno = PyLong_AsLong(linenoobj) - 1;
-        int colno = PyLong_AsLong(colnoobj);
+        int lineno = result->error->line;
+        int colno = result->error->column;
 
         ProblemPointer p(new Problem());
         KTextEditor::Cursor start(lineno, (colno-4 > 0 ? colno-4 : 0));
@@ -143,7 +55,7 @@ CodeAst::Ptr AstBuilder::parse(const QUrl& filename, QString &contents)
         qCDebug(KDEV_PYTHON_PARSER) << "Problem range: " << range;
         DocumentRange location(IndexedString(filename.path()), range);
         p->setFinalLocation(location);
-        p->setDescription(PyUnicodeObjectToQString(errorMessage_str));
+        p->setDescription(result->error->message);
         p->setSource(IProblem::Parser);
         m_problems.append(p);
         
@@ -217,11 +129,11 @@ CodeAst::Ptr AstBuilder::parse(const QUrl& filename, QString &contents)
             }
         }
 
-        syntaxtree = _PyParser_ASTFromString(contents.toUtf8(), placeholderFilename.get(), Py_file_input, &flags, arena);
+        result = parsePythonCode(contents.toUtf8());
         // 3rd try: discard everything after the last non-empty line, but only until the next block start
         currentLineBeginning = qMin(contents.length() - 1, currentLineBeginning);
         errline = qMax(0, qMin(indents.length()-1, errline));
-        if ( ! syntaxtree ) {
+        if ( result->error ) {
             qCWarning(KDEV_PYTHON_PARSER) << "Discarding parts of the code to be parsed because of previous errors";
             qCDebug(KDEV_PYTHON_PARSER) << indents;
             int indentAtError = indents.at(errline);
@@ -259,13 +171,17 @@ CodeAst::Ptr AstBuilder::parse(const QUrl& filename, QString &contents)
                 if ( c.isSpace() && atLineBeginning ) currentIndent += 1;
             }
             qCDebug(KDEV_PYTHON_PARSER) << "This is what is left: " << contents;
-            syntaxtree = _PyParser_ASTFromString(contents.toUtf8(), placeholderFilename.get(), Py_file_input, &flags, arena);
+            result = parsePythonCode(contents.toUtf8());
         }
-        if ( ! syntaxtree ) {
+        if ( result->error ) {
             return CodeAst::Ptr(); // everything fails, so we abort.
         }
     }
-#endif
+
+    auto ast = astFromXml(result->xmlOut);
+    if (!ast) {
+        qCWarning(KDEV_PYTHON_PARSER) << "Internal error while deserializing parser results";
+    }
 
     RangeFixVisitor fixVisitor(contents);
     fixVisitor.visitNode(ast);
diff --git a/parser/astfromxml.cpp b/parser/astfromxml.cpp
index 8c572623..5a77919a 100644
--- a/parser/astfromxml.cpp
+++ b/parser/astfromxml.cpp
@@ -26,6 +26,8 @@ Ast* getSingleElement(Ast* parent, Stream& s)
 {
     auto ok = s.readNextStartElement();
     qDebug() << "read element:" << s.name() << "at end" << s.atEnd() << "error" << s.errorString()  << "ok" << ok;
+    if (s.name() == "vararg")
+        Q_ASSERT(false);
     if (!ok) {
         return nullptr;
     }
@@ -38,6 +40,7 @@ Ast* getSingleElement(Ast* parent, Stream& s)
         return ast;
 
     qWarning() << "Invalid AST type encountered:" << astType << "name" << name.toString();
+    Q_ASSERT(false);
     return nullptr;
 }
 
@@ -56,6 +59,7 @@ void singleFromXml(Ast* parent, AstT*& ret, Stream& s)
     auto* ast = getSingleElement(parent, s);
     ret = static_cast<AstT*>(ast);
     [[maybe_unused]] auto end = s.readNextStartElement();
+    qDebug() << "expecting end:" << end << s.name();
     Q_ASSERT(!end && s.tokenType() == QXmlStreamReader::EndElement);
 }
 
diff --git a/parser/python_header.h b/parser/python_header.h
index 83c6954f..225d97af 100644
--- a/parser/python_header.h
+++ b/parser/python_header.h
@@ -13,7 +13,8 @@
 // remove interfering qt macro
 #undef slots
 
-#include <language/duchain/duchainlock.h>
+#include <sys/types.h>
+#include <unistd.h>
 
 #include "pyport.h"
 #ifndef _WIN32
@@ -22,12 +23,6 @@
 
 #include "Python.h"
 
-#include <internal/pycore_ast.h>
-#include "ast.h"
-
-#include <internal/pycore_ast_state.h>
-#include <internal/pycore_parser.h>
-
 #include <unicodeobject.h>
 
 #include <object.h>
diff --git a/parser/pythonrun.cpp b/parser/pythonrun.cpp
new file mode 100644
index 00000000..74e72b72
--- /dev/null
+++ b/parser/pythonrun.cpp
@@ -0,0 +1,114 @@
+#include "pythonrun.h"
+#include "python_header.h"
+#include "parserdebug.h"
+
+#include <QStringList>
+#include <QFile>
+
+namespace {
+
+using namespace Python;
+
+std::optional<ParseError> parseErrorFromString(QByteArray const& data) {
+    auto const lineData = QString::fromUtf8(data);
+    auto const& lines = lineData.split("\n");
+    if (lines.size() < 5) {
+        return std::nullopt;
+    }
+
+    ParseError ret;
+    bool ok;
+    ret.file = lines[1];
+    ret.line = lines[2].toInt(&ok);
+    if (!ok) {
+        return std::nullopt;
+    }
+    ret.column = lines[3].toInt(&ok);
+    if (!ok) {
+        return std::nullopt;
+    }
+    ret.message = lines.mid(4, -1).join("\n");
+
+    return ret;
+}
+
+class ParserModule {
+public:
+    ParserModule() {
+        Py_Initialize();
+
+        m_module = PyModule_New("parser");
+        auto* localVars = PyModule_GetDict(m_module);
+
+        auto codeFile = QFile(":/ast2xml.py");
+        codeFile.open(QIODevice::ReadOnly);
+        auto const& code = codeFile.readAll();
+        auto* ret = PyRun_String(code.data(), Py_file_input, localVars, localVars);
+        if (!ret) {
+            return;
+        }
+        Py_DECREF(ret);
+
+        m_func = PyObject_GetAttrString(m_module, "doParse");
+    }
+
+    ~ParserModule() {
+        Py_DECREF(m_func);
+        Py_DECREF(m_module);
+        Py_Finalize();
+    }
+
+    bool isInitialized() const {
+        return m_func != nullptr;
+    }
+
+    std::optional<ParseResult> parse(QByteArray const& in) {
+        if (!isInitialized()) {
+            qCWarning(KDEV_PYTHON_PARSER) << "Failed to initialize";
+            return std::nullopt;
+        }
+
+        auto* args = PyTuple_New(1);
+        auto* value = PyUnicode_FromString(in.data());
+        PyTuple_SetItem(args, 0, value);
+
+        value = PyObject_CallObject(m_func, args);
+        Py_DECREF(args);
+        if (!value) {
+            qCWarning(KDEV_PYTHON_PARSER) << "Failed to call function";
+            return std::nullopt;
+        }
+        ssize_t size;
+        const auto* result = PyUnicode_AsUTF8AndSize(value, &size);
+        const auto resultBytes = QByteArray(result, size);
+
+        std::optional<ParseResult> ret;
+        if (size > 0 && result[0] == '<') {
+            ret = ParseResult{std::nullopt, resultBytes};
+        }
+        else if (auto const error = parseErrorFromString(resultBytes)) {
+            ret = ParseResult{error, {}};
+        }
+        else {
+            qCWarning(KDEV_PYTHON_PARSER) << "Invalid result:" << result;
+        }
+        Py_DECREF(value);
+
+        return ret;
+    }
+
+    PyObject* m_module = nullptr;
+    PyObject* m_func = nullptr;
+};
+
+}
+
+namespace Python {
+
+std::optional<ParseResult> parsePythonCode(QByteArray const& code)
+{
+    static ParserModule parserTool;
+    return parserTool.parse(code);
+}
+
+}
diff --git a/parser/pythonrun.h b/parser/pythonrun.h
new file mode 100644
index 00000000..61de303d
--- /dev/null
+++ b/parser/pythonrun.h
@@ -0,0 +1,24 @@
+#pragma once
+#include "python_header.h"
+
+#include <optional>
+
+#include <QByteArray>
+#include <QString>
+
+namespace Python {
+
+struct ParseError {
+    QString file;
+    int line, column;
+    QString message;
+};
+
+struct ParseResult {
+    std::optional<ParseError> error;
+    QByteArray xmlOut;
+};
+
+std::optional<ParseResult> parsePythonCode(QByteArray const& code);
+
+}
diff --git a/parser/resources.qrc b/parser/resources.qrc
new file mode 100644
index 00000000..3dc50814
--- /dev/null
+++ b/parser/resources.qrc
@@ -0,0 +1,6 @@
+<!DOCTYPE RCC>
+<RCC version="1.0">
+    <qresource>
+        <file>ast2xml.py</file>
+    </qresource>
+</RCC>
-- 
GitLab


From 5bfe44f015cf007366648916ce95d5ef572cff51 Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Mon, 21 Mar 2022 10:54:34 +0100
Subject: [PATCH 23/29] cleanup

---
 CMakeLists.txt                        |   4 +-
 duchain/declarationbuilder.cpp        |   1 -
 duchain/tests/pyduchaintest.cpp       |   1 -
 parser/astfromxml.cpp                 |   3 -
 parser/astfromxml_detail/nodereader.h |   9 -
 parser/conversionGenerator.py         | 331 ----------
 parser/generated.h                    | 851 --------------------------
 parser/python310.sdef                 | 147 -----
 8 files changed, 2 insertions(+), 1345 deletions(-)
 delete mode 100644 parser/conversionGenerator.py
 delete mode 100644 parser/generated.h
 delete mode 100644 parser/python310.sdef

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 339bfd33..37460a9f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -43,7 +43,7 @@ add_definitions( -DTRANSLATION_DOMAIN=\"kdevpython\" )
 
 # CMake looks for exactly the specified version first and ignores newer versions.
 # To avoid that, start looking for the newest supported version and work down.
-set(Python_ADDITIONAL_VERSIONS 3.9 3.8 3.7 3.6 3.5 3.4)
+set(Python_ADDITIONAL_VERSIONS 3.10 3.9 3.8 3.7 3.6 3.5 3.4)
 foreach(_PYTHON_V ${Python_ADDITIONAL_VERSIONS})
     find_package(PythonInterp ${_PYTHON_V})
     if ( PYTHONINTERP_FOUND )
@@ -61,7 +61,7 @@ if ( PYTHONINTERP_FOUND AND PYTHON_VERSION_STRING VERSION_GREATER "3.4" )
 endif()
 
 if ( NOT PYTHONLIBS_FOUND OR PYTHONLIBS_VERSION_STRING VERSION_LESS "3.4.3" )
-    message(FATAL_ERROR "Python >= 3.4.3 but < 3.10 with --enable-shared is required to build kdev-python")
+    message(FATAL_ERROR "Python >= 3.4.3 but <= 3.10 with --enable-shared is required to build kdev-python")
 endif()
 
 configure_file(kdevpythonversion.h.cmake "${CMAKE_CURRENT_BINARY_DIR}/kdevpythonversion.h" @ONLY)
diff --git a/duchain/declarationbuilder.cpp b/duchain/declarationbuilder.cpp
index 64b68c36..b7dc9573 100644
--- a/duchain/declarationbuilder.cpp
+++ b/duchain/declarationbuilder.cpp
@@ -1590,7 +1590,6 @@ QString DeclarationBuilder::getDocstring(QList< Python::Ast* > body) const
         ConstantAst* docstring = static_cast<ConstantAst*>(static_cast<ExpressionAst*>(body.first())->value);
         docstring->usedAsComment = true;
         if (auto* string = std::get_if<QString>(&docstring->value)) {
-            qDebug() << "setting function docstring:" << *string;
             return string->trimmed();
         }
     }
diff --git a/duchain/tests/pyduchaintest.cpp b/duchain/tests/pyduchaintest.cpp
index 3d41dcc9..1c11f571 100644
--- a/duchain/tests/pyduchaintest.cpp
+++ b/duchain/tests/pyduchaintest.cpp
@@ -728,7 +728,6 @@ void PyDUChainTest::testRanges()
         visitor->searchingForRange = r;
         visitor->searchingForIdentifier = identifier;
         visitor->visitCode(m_ast.data());
-        QEXPECT_FAIL("attr_dot_name_hash", "Insufficiently magic hack", Continue);
         QCOMPARE(visitor->found, true);
         delete visitor;
     }
diff --git a/parser/astfromxml.cpp b/parser/astfromxml.cpp
index 5a77919a..f541f3ea 100644
--- a/parser/astfromxml.cpp
+++ b/parser/astfromxml.cpp
@@ -25,7 +25,6 @@ struct ToEndElement {
 Ast* getSingleElement(Ast* parent, Stream& s)
 {
     auto ok = s.readNextStartElement();
-    qDebug() << "read element:" << s.name() << "at end" << s.atEnd() << "error" << s.errorString()  << "ok" << ok;
     if (s.name() == "vararg")
         Q_ASSERT(false);
     if (!ok) {
@@ -50,7 +49,6 @@ void listFromXml(Ast* parent, QList<AstT*>& ret, Stream& s)
     while (auto* ast = getSingleElement(parent, s)) {
         ret.push_back(static_cast<AstT*>(ast));
     }
-    qDebug() << "read:" << ret.size() << "list items";
 }
 
 template<typename AstT>
@@ -59,7 +57,6 @@ void singleFromXml(Ast* parent, AstT*& ret, Stream& s)
     auto* ast = getSingleElement(parent, s);
     ret = static_cast<AstT*>(ast);
     [[maybe_unused]] auto end = s.readNextStartElement();
-    qDebug() << "expecting end:" << end << s.name();
     Q_ASSERT(!end && s.tokenType() == QXmlStreamReader::EndElement);
 }
 
diff --git a/parser/astfromxml_detail/nodereader.h b/parser/astfromxml_detail/nodereader.h
index c51cb702..daaf8846 100644
--- a/parser/astfromxml_detail/nodereader.h
+++ b/parser/astfromxml_detail/nodereader.h
@@ -50,7 +50,6 @@ struct NodeReadHelper {
         }
         else {
             if (attributeName == *(global_attribute_names.begin() - (N+1))) {
-                qDebug() << "read global attribute:" << attributeName << attributeValue;
                 r->readGlobalAttribute(AttributeTag<N>{}, attributeValue);
                 return;
             }
@@ -86,18 +85,12 @@ struct NodeReadHelper {
     void readChildren(Stream& s) {
         if constexpr (ChildCount > 0) {
             auto const name = s.name();
-            qDebug() << " >> starting read of child attribute list for " << name;
             while (s.readNextStartElement()) {
                 auto childName = s.name();
-                qDebug() << "read child attribute of" << name << ":" << s.name();
                 readSingleChild<ChildCount - 1>(s.name(), s);
-                qDebug() << "done reading child attribute of" << name << ":" << childName;
-                qDebug() << "last read" << s.name() << "isEndTag" << (s.tokenType() == QXmlStreamReader::EndElement);
             }
-            qDebug() << " << finished read list:" << name << "read end:" << s.tokenType() << s.name();
         }
         else {
-            qDebug() << " ** " << s.name() << "has no children, skipping it.";
             s.readNextStartElement();
         }
     };
@@ -116,11 +109,9 @@ void doReadNode(Derived* r, Stream& s)
     >;
 
     auto const name = s.name();
-    qDebug() << " ------- Deserializing:" << name;
     ThisReader reader(r, r->AttributeNames, r->ChildNames);
     reader.readAttributes(s);
     reader.readChildren(s);
-    qDebug() << " ++++++++ Done:" << name;
 }
 
 template<typename AstT>
diff --git a/parser/conversionGenerator.py b/parser/conversionGenerator.py
deleted file mode 100644
index 45c3e489..00000000
--- a/parser/conversionGenerator.py
+++ /dev/null
@@ -1,331 +0,0 @@
-#!/usr/bin/env python
-
-# SPDX-FileCopyrightText: 2014 Sven Brauch <svenbrauch@gmail.com>
-# SPDX-License-Identifier: GPL-2.0-or-later
-
-# Transforms a conversion definition file (.sdef) into C++ code. To be copied over manually. :)
-# sdef example line:
-# RULE_FOR _stmt;KIND Expr_kind;ACTIONS create|ExpressionAst set|value->ExpressionAst,value;CODE;;
-
-import sys
-
-contents = open('python310.sdef').read().replace("\n", "").split(';;')
-
-func_structure = '''
-    Ast* visitNode(%{RULE_FOR}* node) {
-        if ( ! node ) return nullptr;
-        bool ranges_copied = false; Q_UNUSED(ranges_copied);
-        Ast* result = nullptr;
-        switch ( node->kind ) {
-%{SWITCH_LINES}
-        default:
-            qWarning() << "Unsupported %{RULE_FOR} AST type: " << node->kind;
-            Q_ASSERT(false);
-        }
-%{APPENDIX}
-        if ( result && result->astType == Ast::NameAstType ) {
-            NameAst* r = static_cast<NameAst*>(result);
-            r->startCol = r->identifier->startCol;
-            r->endCol = r->identifier->endCol;
-            r->startLine = r->identifier->startLine;
-            r->endLine = r->identifier->endLine;
-        }
-        return result;
-    }
-'''
-
-simple_func_structure = '''
-    Ast* visitNode(%{RULE_FOR}* node) {
-        bool ranges_copied = false; Q_UNUSED(ranges_copied);
-        if ( ! node ) return nullptr;
-%{SWITCH_LINES}
-        return v;
-    }
-'''
-
-switch_line = '''        case %{KIND}: {
-%{ACTIONS}
-                break;
-            }'''
-
-create_ast_line = '''                %{AST_TYPE}* v = new  %{AST_TYPE}(parent());'''
-create_identifier_line = '''                v->%{TARGET} = node->v.%{KIND_W/O_SUFFIX}.%{VALUE} ? new Python::Identifier(PyUnicodeObjectToQString(node->v.%{KIND_W/O_SUFFIX}.%{VALUE})) : nullptr;'''
-set_attribute_line = '''                nodeStack.push(v); v->%{TARGET} = static_cast<%{AST_TYPE}*>(visitNode(node->v.%{KIND_W/O_SUFFIX}.%{VALUE})); nodeStack.pop();'''
-resolve_list_line = '''                nodeStack.push(v); v->%{TARGET} = visitNodeList<%{PYTHON_AST_TYPE}, %{AST_TYPE}>(node->v.%{KIND_W/O_SUFFIX}.%{VALUE}); nodeStack.pop();'''
-create_identifier_line_any = '''            v->%{TARGET} = node->%{VALUE} ? new Python::Identifier(PyUnicodeObjectToQString(node->%{VALUE})) : nullptr;'''
-set_attribute_line_any = '''            nodeStack.push(v); v->%{TARGET} = static_cast<%{AST_TYPE}*>(visitNode(node->%{VALUE})); nodeStack.pop();'''
-resolve_list_line_any = '''            nodeStack.push(v); v->%{TARGET} = visitNodeList<%{PYTHON_AST_TYPE}, %{AST_TYPE}>(node->%{VALUE}); nodeStack.pop();'''
-direct_assignment_line = '''                v->%{TARGET} = node->v.%{KIND_W/O_SUFFIX}.%{VALUE};'''
-direct_assignment_line_any = '''                v->%{TARGET} = node->v.%{VALUE};'''
-cast_operator_line = '''                v->%{TARGET} = (ExpressionAst::%{AST_TYPE}) node->v.%{KIND_W/O_SUFFIX}.%{VALUE};'''
-resolve_string = '''                v->%{TARGET} = PyUnicodeObjectToQString(node->v.%{KIND_W/O_SUFFIX}.%{VALUE});'''
-assign_mindless = '''              v->%{TARGET} = node->%{VALUE};'''
-assign_linetransform = '''              v->%{TARGET} = tline(node->%{VALUE} - 1);'''
-singleton_convert_line = '''                v->%{TARGET} = node->v.NameConstant.value == Py_None ? NameConstantAst::None : node->v.NameConstant.value == Py_False ? NameConstantAst::False : NameConstantAst::True;'''
-resolve_oplist_block = '''
-                for ( int _i = 0; _i < node->v.%{KIND_W/O_SUFFIX}.%{VALUE}->size; _i++ ) {
-                    #if PYTHON_VERSION < QT_VERSION_CHECK(3, 10, 0)
-                    v->%{TARGET}.append((ExpressionAst::%{AST_TYPE}) node->v.%{KIND_W/O_SUFFIX}.%{VALUE}->elements[_i]);
-                    #else
-                    v->%{TARGET}.append((ExpressionAst::%{AST_TYPE}) node->v.%{KIND_W/O_SUFFIX}.%{VALUE}->typed_elements[_i]);
-                    #endif
-                }
-'''
-resolve_identifier_block = '''
-                for ( int _i = 0; _i < node->v.%{KIND_W/O_SUFFIX}.%{VALUE}->size; _i++ ) {
-                    Python::Identifier* id = new Python::Identifier(PyUnicodeObjectToQString(
-                                    static_cast<PyObject*>(node->v.%{KIND_W/O_SUFFIX}.%{VALUE}->elements[_i])
-                            ));
-                    v->%{TARGET}.append(id);
-                }
-'''
-
-copy_ident_ranges = '''
-                if ( v->%{TARGET} ) {
-                    v->%{TARGET}->startCol = node->col_offset; v->startCol = v->%{TARGET}->startCol;
-                    v->%{TARGET}->startLine = tline(node->lineno - 1);  v->startLine = v->%{TARGET}->startLine;
-                    v->%{TARGET}->endCol = node->col_offset + v->%{TARGET}->value.length() - 1;  v->endCol = v->%{TARGET}->endCol;
-                    v->%{TARGET}->endLine = tline(node->lineno - 1);  v->endLine = v->%{TARGET}->endLine;
-                    ranges_copied = true;
-                }'''
-
-
-results = dict()
-does_match_any = dict()
-
-def pluginAstToPythonAstType(plugintypestr):
-    if plugintypestr == 'ExpressionAst': return '_expr'
-    if plugintypestr == 'StatementAst' : return '_stmt'
-    if plugintypestr == 'NameAst': return '_expr'
-    if plugintypestr == 'ExceptionHandlerAst': return '_excepthandler'
-    if plugintypestr == 'ComprehensionAst': return '_comprehension'
-    if plugintypestr == 'KeywordAst': return '_keyword'
-    if plugintypestr == 'ArgumentsAst': return '_arguments'
-    if plugintypestr == 'AliasAst': return '_alias'
-    if plugintypestr == 'SliceAst': return '_slice'
-    if plugintypestr == 'Ast': return '_stmt' # not sure about this
-    if plugintypestr == 'GeneratorExpressionAst': return '_expr'
-    if plugintypestr == 'ArgAst': return '_arg'
-    if plugintypestr == 'WithItemAst': return '_withitem'
-    else:
-        sys.stderr.write("W: Could not decode name %s\n" % plugintypestr)
-        return '<ERROR>'
-
-for rule in contents:
-    outline = rule.split(';')
-    command = outline[0]
-    if command[:7] == 'COMMENT' or command == '':
-        continue
-    elif command[:7] != 'RULE_FO':
-        raise SyntaxError('Invalid syntax in sdef file, line: ' + rule)
-    
-    rule_for = outline[0].split(' ')[1]
-    kind = outline[1].split(' ')[1]
-    kind_wo_suffix = kind.replace('_kind', '')
-    actions = outline[2].split(' ')[1:]
-    code = None
-    since_version = None
-    before_version = None
-    if len(outline) > 3:
-        if outline[3].startswith('BEFORE'):
-            before_version = [int(n) for n in outline[3][7:].split('.')]
-        elif outline[3].startswith('SINCE'):
-            since_version = [int(n) for n in outline[3][6:].split('.')]
-        elif outline[3].startswith('CODE'):
-            code = ' '.join(';'.join(outline[3:]).split('CODE')[1:]) + ";"
-        else:
-            raise SyntaxError('Invalid syntax in sdef file, line: ' + rule)
-    if len(outline) > 4 and outline[4].startswith('CODE'):
-        code = ' '.join(';'.join(outline[4:]).split('CODE')[1:]) + ";"
-    
-    if rule_for not in results:
-        results[rule_for] = list()
-    
-    current_actions = list()
-    created_v = False
-    for action in actions:
-        command = action.split('|')[0]
-        try:
-            arguments = action.split('|')[1]
-        except IndexError:
-            continue
-        action = '<ERROR>'
-        if command == 'set':
-            s = arguments.split('>')
-            commandType = s[0][-1] # -, ~, =, : , *, #
-            target = s[0][:-1]
-            s = s[1].split(',')
-            raw = False
-            
-            if kind == 'any': any = True
-            else: any = False
-            
-            
-            # commands with one argument
-            if commandType in ['~', ':', '$', '+', 'l', '_']:
-                if commandType == '_':
-                    raw = singleton_convert_line
-                if commandType == ':':
-                    raw = direct_assignment_line if not any else direct_assignment_line_any
-                if commandType == '~':
-                    raw = create_identifier_line if not any else create_identifier_line_any
-                    if rule_for in ['_expr', '_stmt', '_excepthandler', '_arg']:
-                        raw += copy_ident_ranges
-                if commandType == '$':
-                    raw = resolve_string
-                if commandType == '+':
-                    raw = assign_mindless;
-                if commandType == 'l':
-                    raw = assign_linetransform;
-                value = s[0]
-            # commands with two arguments
-            else:
-                astType = s[0]
-                try:
-                    value = s[1]
-                except IndexError:
-                    raise SyntaxError('Missing argument for operator ' + commandType + ' in rule: ' + rule)
-                if commandType == '=':
-                    if astType == 'Identifier':
-                        raw = resolve_identifier_block
-                    else:
-                        raw = resolve_list_line if not any else resolve_list_line_any
-                if commandType == '-':
-                    raw = set_attribute_line if not any else set_attribute_line_any
-                if commandType == '*':
-                    raw = cast_operator_line
-                if commandType == '#':
-                    raw = resolve_oplist_block
-            
-            if raw:
-                command = raw.replace('%{AST_TYPE}', astType).replace('%{TARGET}', target) \
-                             .replace('%{PYTHON_AST_TYPE}', pluginAstToPythonAstType(astType)) \
-                             .replace('%{KIND_W/O_SUFFIX}', kind_wo_suffix).replace('%{VALUE}', value)
-            else: command = '<MISSING RAW>'
-            
-            current_actions.append(command)
-            
-        elif command == 'create':
-            astType = arguments
-            current_actions.append(create_ast_line.replace('%{AST_TYPE}', astType))
-            created_v = True
-
-    if code:
-        current_actions.append(code);
-
-    current_actions = "\n".join(current_actions)
-    if kind == 'any':
-        current_stmt = current_actions
-    else:
-        if created_v:
-            current_actions += "\n                result = v;"
-        current_stmt = switch_line.replace('%{KIND}', kind).replace('%{ACTIONS}', current_actions)
-    if before_version:
-        version_cpp_if = ("#if PYTHON_VERSION < QT_VERSION_CHECK(%d, %d, 0)\n"
-                           %(before_version[0], before_version[1]))
-        current_stmt = version_cpp_if + current_stmt + "\n#endif"
-    if since_version:
-        version_cpp_if = ("#if PYTHON_VERSION >= QT_VERSION_CHECK(%d, %d, 0)\n"
-                           %(since_version[0], since_version[1]))
-        current_stmt = version_cpp_if + current_stmt + "\n#endif"
-    results[rule_for].append(current_stmt)
-    does_match_any[rule_for] = any
-
-print('''#pragma once
-
-/* This code is generated by conversiongenerator.py.
- * I do not recommend editing it.
- * To update, run: python2 conversionGenerator.py > generated.h
- */
-
-#include <QStack>
-#include "kdevpythonversion.h"
-
-class PythonAstTransformer {
-public:
-    CodeAst* ast;
-    void run(mod_ty syntaxtree, QString moduleName) {
-        ast = new CodeAst();
-        ast->name = new Identifier(moduleName);
-        nodeStack.push(ast);
-        ast->body = visitNodeList<_stmt, Ast>(syntaxtree->v.Module.body);
-        nodeStack.pop();
-        Q_ASSERT(nodeStack.isEmpty());
-    }
-    // Shift lines by some fixed amount
-    inline int tline(int line) {
-        if ( line == -99999 ) {
-            // don't touch the marker
-            return -99999;
-        }
-        return line;
-    };
-private:
-    QStack<Ast*> nodeStack;
-
-    Ast* parent() {
-        return nodeStack.top();
-    }
-    
-    template<typename T, typename K, typename Seq> QList<K*> visitNodeList(Seq* node) {
-        QList<K*> nodelist;
-        if ( ! node ) return nodelist;
-        for ( int i=0; i < node->size; i++ ) {
-            T* currentNode = static_cast<T*>(node->elements[i]);
-            Ast* result = visitNode(currentNode);
-            K* transformedNode = static_cast<K*>(result);
-            nodelist.append(transformedNode);
-        }
-        return nodelist;
-    }
-
-''')
-
-for index, lines in sorted(results.items()):
-    current_switch_lines = "\n".join(lines)
-    appendix = ''
-    if index == '_expr' or index == '_stmt':
-        appendix = '''
-	if ( ! result ) return nullptr;
-        if ( ! ranges_copied ) {
-            result->startCol = node->col_offset;
-            result->endCol = node->col_offset;
-            result->startLine = tline(node->lineno - 1);
-            result->endLine = tline(node->lineno - 1);
-            result->hasUsefulRangeInformation = true;
-        }
-        else {
-            result->hasUsefulRangeInformation = true;
-        }
-        '''
-    appendix += '''
-        // Walk through the tree and set proper end columns and lines, as the python parser sadly does not do this for us
-        if ( result->hasUsefulRangeInformation ) {
-            Ast* parent = result->parent;
-            while ( parent ) {
-                if ( parent->endLine < result->endLine ) {
-                    parent->endLine = result->endLine;
-                    parent->endCol = result->endCol;
-                }
-                if ( ! parent->hasUsefulRangeInformation && parent->startLine == -99999 ) {
-                    parent->startLine = result->startLine;
-                    parent->startCol = result->startCol;
-                }
-                parent = parent->parent;
-            }
-        }
-    '''
-    if not does_match_any[index]:
-        func = func_structure.replace('%{RULE_FOR}', index).replace('%{SWITCH_LINES}', current_switch_lines).replace('%{APPENDIX}', appendix)
-    else:
-        func = simple_func_structure.replace('%{RULE_FOR}', index).replace('%{SWITCH_LINES}', current_switch_lines)
-    if index == '_slice':
-        func = "#if PYTHON_VERSION < QT_VERSION_CHECK(3, 9, 0)\n" + func + "\n#endif\n"
-    print(func)
-
-print('''};
-
-/*
- * End generated code
- */
-''')
diff --git a/parser/generated.h b/parser/generated.h
deleted file mode 100644
index 43077831..00000000
--- a/parser/generated.h
+++ /dev/null
@@ -1,851 +0,0 @@
-#pragma once
-
-/* This code is generated by conversiongenerator.py.
- * I do not recommend editing it.
- * To update, run: python2 conversionGenerator.py > generated.h
- */
-
-#include <QStack>
-#include "kdevpythonversion.h"
-
-class PythonAstTransformer {
-public:
-    CodeAst* ast;
-    void run(mod_ty syntaxtree, QString moduleName) {
-        ast = new CodeAst();
-        ast->name = new Identifier(moduleName);
-        nodeStack.push(ast);
-        ast->body = visitNodeList<_stmt, Ast>(syntaxtree->v.Module.body);
-        nodeStack.pop();
-        Q_ASSERT(nodeStack.isEmpty());
-    }
-    // Shift lines by some fixed amount
-    inline int tline(int line) {
-        if ( line == -99999 ) {
-            // don't touch the marker
-            return -99999;
-        }
-        return line;
-    };
-private:
-    QStack<Ast*> nodeStack;
-
-    Ast* parent() {
-        return nodeStack.top();
-    }
-    
-    template<typename T, typename K, typename Seq> QList<K*> visitNodeList(Seq* node) {
-        QList<K*> nodelist;
-        if ( ! node ) return nodelist;
-        for ( int i=0; i < node->size; i++ ) {
-            T* currentNode = static_cast<T*>(node->elements[i]);
-            Ast* result = visitNode(currentNode);
-            K* transformedNode = static_cast<K*>(result);
-            nodelist.append(transformedNode);
-        }
-        return nodelist;
-    }
-
-
-
-    Ast* visitNode(_alias* node) {
-        bool ranges_copied = false; Q_UNUSED(ranges_copied);
-        if ( ! node ) return nullptr;
-                AliasAst* v = new  AliasAst(parent());
-            v->name = node->name ? new Python::Identifier(PyUnicodeObjectToQString(node->name)) : nullptr;
-            v->asName = node->asname ? new Python::Identifier(PyUnicodeObjectToQString(node->asname)) : nullptr;
-        return v;
-    }
-
-
-    Ast* visitNode(_arg* node) {
-        bool ranges_copied = false; Q_UNUSED(ranges_copied);
-        if ( ! node ) return nullptr;
-                ArgAst* v = new  ArgAst(parent());
-            v->argumentName = node->arg ? new Python::Identifier(PyUnicodeObjectToQString(node->arg)) : nullptr;
-                if ( v->argumentName ) {
-                    v->argumentName->startCol = node->col_offset; v->startCol = v->argumentName->startCol;
-                    v->argumentName->startLine = tline(node->lineno - 1);  v->startLine = v->argumentName->startLine;
-                    v->argumentName->endCol = node->col_offset + v->argumentName->value.length() - 1;  v->endCol = v->argumentName->endCol;
-                    v->argumentName->endLine = tline(node->lineno - 1);  v->endLine = v->argumentName->endLine;
-                    ranges_copied = true;
-                }
-            nodeStack.push(v); v->annotation = static_cast<ExpressionAst*>(visitNode(node->annotation)); nodeStack.pop();
-        return v;
-    }
-
-
-    Ast* visitNode(_arguments* node) {
-        bool ranges_copied = false; Q_UNUSED(ranges_copied);
-        if ( ! node ) return nullptr;
-#if PYTHON_VERSION < QT_VERSION_CHECK(3, 8, 0)
-                ArgumentsAst* v = new  ArgumentsAst(parent());
-            nodeStack.push(v); v->vararg = static_cast<ArgAst*>(visitNode(node->vararg)); nodeStack.pop();
-            nodeStack.push(v); v->kwarg = static_cast<ArgAst*>(visitNode(node->kwarg)); nodeStack.pop();
-            nodeStack.push(v); v->arguments = visitNodeList<_arg, ArgAst>(node->args); nodeStack.pop();
-            nodeStack.push(v); v->defaultValues = visitNodeList<_expr, ExpressionAst>(node->defaults); nodeStack.pop();
-            nodeStack.push(v); v->kwonlyargs = visitNodeList<_arg, ArgAst>(node->kwonlyargs); nodeStack.pop();
-#endif
-#if PYTHON_VERSION >= QT_VERSION_CHECK(3, 8, 0)
-                ArgumentsAst* v = new  ArgumentsAst(parent());
-            nodeStack.push(v); v->vararg = static_cast<ArgAst*>(visitNode(node->vararg)); nodeStack.pop();
-            nodeStack.push(v); v->kwarg = static_cast<ArgAst*>(visitNode(node->kwarg)); nodeStack.pop();
-            nodeStack.push(v); v->arguments = visitNodeList<_arg, ArgAst>(node->args); nodeStack.pop();
-            nodeStack.push(v); v->defaultValues = visitNodeList<_expr, ExpressionAst>(node->defaults); nodeStack.pop();
-            nodeStack.push(v); v->kwonlyargs = visitNodeList<_arg, ArgAst>(node->kwonlyargs); nodeStack.pop();
-            nodeStack.push(v); v->posonlyargs = visitNodeList<_arg, ArgAst>(node->posonlyargs); nodeStack.pop();
-#endif
-        return v;
-    }
-
-
-    Ast* visitNode(_comprehension* node) {
-        bool ranges_copied = false; Q_UNUSED(ranges_copied);
-        if ( ! node ) return nullptr;
-                ComprehensionAst* v = new  ComprehensionAst(parent());
-            nodeStack.push(v); v->target = static_cast<ExpressionAst*>(visitNode(node->target)); nodeStack.pop();
-            nodeStack.push(v); v->iterator = static_cast<ExpressionAst*>(visitNode(node->iter)); nodeStack.pop();
-            nodeStack.push(v); v->conditions = visitNodeList<_expr, ExpressionAst>(node->ifs); nodeStack.pop();
-        return v;
-    }
-
-
-    Ast* visitNode(_excepthandler* node) {
-        if ( ! node ) return nullptr;
-        bool ranges_copied = false; Q_UNUSED(ranges_copied);
-        Ast* result = nullptr;
-        switch ( node->kind ) {
-        case ExceptHandler_kind: {
-                ExceptionHandlerAst* v = new  ExceptionHandlerAst(parent());
-                nodeStack.push(v); v->type = static_cast<ExpressionAst*>(visitNode(node->v.ExceptHandler.type)); nodeStack.pop();
-                v->name = node->v.ExceptHandler.name ? new Python::Identifier(PyUnicodeObjectToQString(node->v.ExceptHandler.name)) : nullptr;
-                if ( v->name ) {
-                    v->name->startCol = node->col_offset; v->startCol = v->name->startCol;
-                    v->name->startLine = tline(node->lineno - 1);  v->startLine = v->name->startLine;
-                    v->name->endCol = node->col_offset + v->name->value.length() - 1;  v->endCol = v->name->endCol;
-                    v->name->endLine = tline(node->lineno - 1);  v->endLine = v->name->endLine;
-                    ranges_copied = true;
-                }
-                nodeStack.push(v); v->body = visitNodeList<_stmt, Ast>(node->v.ExceptHandler.body); nodeStack.pop();
-                result = v;
-                break;
-            }
-        default:
-            qWarning() << "Unsupported _excepthandler AST type: " << node->kind;
-            Q_ASSERT(false);
-        }
-
-        // Walk through the tree and set proper end columns and lines, as the python parser sadly does not do this for us
-        if ( result->hasUsefulRangeInformation ) {
-            Ast* parent = result->parent;
-            while ( parent ) {
-                if ( parent->endLine < result->endLine ) {
-                    parent->endLine = result->endLine;
-                    parent->endCol = result->endCol;
-                }
-                if ( ! parent->hasUsefulRangeInformation && parent->startLine == -99999 ) {
-                    parent->startLine = result->startLine;
-                    parent->startCol = result->startCol;
-                }
-                parent = parent->parent;
-            }
-        }
-    
-        if ( result && result->astType == Ast::NameAstType ) {
-            NameAst* r = static_cast<NameAst*>(result);
-            r->startCol = r->identifier->startCol;
-            r->endCol = r->identifier->endCol;
-            r->startLine = r->identifier->startLine;
-            r->endLine = r->identifier->endLine;
-        }
-        return result;
-    }
-
-
-    Ast* visitNode(_expr* node) {
-        if ( ! node ) return nullptr;
-        bool ranges_copied = false; Q_UNUSED(ranges_copied);
-        Ast* result = nullptr;
-        switch ( node->kind ) {
-#if PYTHON_VERSION >= QT_VERSION_CHECK(3, 5, 0)
-        case Await_kind: {
-                AwaitAst* v = new  AwaitAst(parent());
-                nodeStack.push(v); v->value = static_cast<ExpressionAst*>(visitNode(node->v.Await.value)); nodeStack.pop();
-                result = v;
-                break;
-            }
-#endif
-        case BoolOp_kind: {
-                BooleanOperationAst* v = new  BooleanOperationAst(parent());
-                v->type = (ExpressionAst::BooleanOperationTypes) node->v.BoolOp.op;
-                nodeStack.push(v); v->values = visitNodeList<_expr, ExpressionAst>(node->v.BoolOp.values); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case BinOp_kind: {
-                BinaryOperationAst* v = new  BinaryOperationAst(parent());
-                v->type = (ExpressionAst::OperatorTypes) node->v.BinOp.op;
-                nodeStack.push(v); v->lhs = static_cast<ExpressionAst*>(visitNode(node->v.BinOp.left)); nodeStack.pop();
-                nodeStack.push(v); v->rhs = static_cast<ExpressionAst*>(visitNode(node->v.BinOp.right)); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case UnaryOp_kind: {
-                UnaryOperationAst* v = new  UnaryOperationAst(parent());
-                v->type = (ExpressionAst::UnaryOperatorTypes) node->v.UnaryOp.op;
-                nodeStack.push(v); v->operand = static_cast<ExpressionAst*>(visitNode(node->v.UnaryOp.operand)); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case Lambda_kind: {
-                LambdaAst* v = new  LambdaAst(parent());
-                nodeStack.push(v); v->arguments = static_cast<ArgumentsAst*>(visitNode(node->v.Lambda.args)); nodeStack.pop();
-                nodeStack.push(v); v->body = static_cast<ExpressionAst*>(visitNode(node->v.Lambda.body)); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case IfExp_kind: {
-                IfExpressionAst* v = new  IfExpressionAst(parent());
-                nodeStack.push(v); v->condition = static_cast<ExpressionAst*>(visitNode(node->v.IfExp.test)); nodeStack.pop();
-                nodeStack.push(v); v->body = static_cast<ExpressionAst*>(visitNode(node->v.IfExp.body)); nodeStack.pop();
-                nodeStack.push(v); v->orelse = static_cast<ExpressionAst*>(visitNode(node->v.IfExp.orelse)); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case Dict_kind: {
-                DictAst* v = new  DictAst(parent());
-                nodeStack.push(v); v->keys = visitNodeList<_expr, ExpressionAst>(node->v.Dict.keys); nodeStack.pop();
-                nodeStack.push(v); v->values = visitNodeList<_expr, ExpressionAst>(node->v.Dict.values); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case Set_kind: {
-                SetAst* v = new  SetAst(parent());
-                nodeStack.push(v); v->elements = visitNodeList<_expr, ExpressionAst>(node->v.Set.elts); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case ListComp_kind: {
-                ListComprehensionAst* v = new  ListComprehensionAst(parent());
-                nodeStack.push(v); v->element = static_cast<ExpressionAst*>(visitNode(node->v.ListComp.elt)); nodeStack.pop();
-                nodeStack.push(v); v->generators = visitNodeList<_comprehension, ComprehensionAst>(node->v.ListComp.generators); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case SetComp_kind: {
-                SetComprehensionAst* v = new  SetComprehensionAst(parent());
-                nodeStack.push(v); v->element = static_cast<ExpressionAst*>(visitNode(node->v.SetComp.elt)); nodeStack.pop();
-                nodeStack.push(v); v->generators = visitNodeList<_comprehension, ComprehensionAst>(node->v.SetComp.generators); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case DictComp_kind: {
-                DictionaryComprehensionAst* v = new  DictionaryComprehensionAst(parent());
-                nodeStack.push(v); v->key = static_cast<ExpressionAst*>(visitNode(node->v.DictComp.key)); nodeStack.pop();
-                nodeStack.push(v); v->value = static_cast<ExpressionAst*>(visitNode(node->v.DictComp.value)); nodeStack.pop();
-                nodeStack.push(v); v->generators = visitNodeList<_comprehension, ComprehensionAst>(node->v.DictComp.generators); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case GeneratorExp_kind: {
-                GeneratorExpressionAst* v = new  GeneratorExpressionAst(parent());
-                nodeStack.push(v); v->element = static_cast<ExpressionAst*>(visitNode(node->v.GeneratorExp.elt)); nodeStack.pop();
-                nodeStack.push(v); v->generators = visitNodeList<_comprehension, ComprehensionAst>(node->v.GeneratorExp.generators); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case Yield_kind: {
-                YieldAst* v = new  YieldAst(parent());
-                nodeStack.push(v); v->value = static_cast<ExpressionAst*>(visitNode(node->v.Yield.value)); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case Compare_kind: {
-                CompareAst* v = new  CompareAst(parent());
-                nodeStack.push(v); v->leftmostElement = static_cast<ExpressionAst*>(visitNode(node->v.Compare.left)); nodeStack.pop();
-
-                for ( int _i = 0; _i < node->v.Compare.ops->size; _i++ ) {
-                    #if PYTHON_VERSION < QT_VERSION_CHECK(3, 10, 0)
-                    v->operators.append((ExpressionAst::ComparisonOperatorTypes) node->v.Compare.ops->elements[_i]);
-                    #else
-                    v->operators.append((ExpressionAst::ComparisonOperatorTypes) node->v.Compare.ops->typed_elements[_i]);
-                    #endif
-                }
-
-                nodeStack.push(v); v->comparands = visitNodeList<_expr, ExpressionAst>(node->v.Compare.comparators); nodeStack.pop();
-                result = v;
-                break;
-            }
-#if PYTHON_VERSION >= QT_VERSION_CHECK(3, 5, 0)
-        case Call_kind: {
-                CallAst* v = new  CallAst(parent());
-                nodeStack.push(v); v->function = static_cast<ExpressionAst*>(visitNode(node->v.Call.func)); nodeStack.pop();
-                nodeStack.push(v); v->arguments = visitNodeList<_expr, ExpressionAst>(node->v.Call.args); nodeStack.pop();
-                nodeStack.push(v); v->keywords = visitNodeList<_keyword, KeywordAst>(node->v.Call.keywords); nodeStack.pop();
-                result = v;
-                break;
-            }
-#endif
-#if PYTHON_VERSION < QT_VERSION_CHECK(3, 5, 0)
-        case Call_kind: {
-                CallAst* v = new  CallAst(parent());
-                nodeStack.push(v); v->function = static_cast<ExpressionAst*>(visitNode(node->v.Call.func)); nodeStack.pop();
-                nodeStack.push(v); v->arguments = visitNodeList<_expr, ExpressionAst>(node->v.Call.args); nodeStack.pop();
-                nodeStack.push(v); v->keywords = visitNodeList<_keyword, KeywordAst>(node->v.Call.keywords); nodeStack.pop();
- /* Convert 3.4 unpacked-args AST to match the new format from 3.5+ */if (node->v.Call.starargs) {    nodeStack.push(v);    auto starred = new StarredAst(v);    starred->context = ExpressionAst::Context::Load;    nodeStack.push(starred);    starred->value = static_cast<ExpressionAst*>(visitNode(node->v.Call.starargs));    nodeStack.pop();    v->arguments.append(starred);    nodeStack.pop();};if (node->v.Call.kwargs) {    nodeStack.push(v);    auto kwargs = new KeywordAst(v);    nodeStack.push(kwargs);    kwargs->value = static_cast<ExpressionAst*>(visitNode(node->v.Call.kwargs));    nodeStack.pop();    v->keywords.append(kwargs);    nodeStack.pop();};
-                result = v;
-                break;
-            }
-#endif
-#if PYTHON_VERSION < QT_VERSION_CHECK(3, 8, 0)
-        case Num_kind: {
-                NumberAst* v = new  NumberAst(parent());
- v->isInt = PyLong_Check(node->v.Num.n); v->value = PyLong_AsLong(node->v.Num.n);
-                result = v;
-                break;
-            }
-#endif
-#if PYTHON_VERSION < QT_VERSION_CHECK(3, 8, 0)
-        case Str_kind: {
-                StringAst* v = new  StringAst(parent());
-                v->value = PyUnicodeObjectToQString(node->v.Str.s);
-                result = v;
-                break;
-            }
-#endif
-#if PYTHON_VERSION >= QT_VERSION_CHECK(3, 6, 0)
-        case JoinedStr_kind: {
-                JoinedStringAst* v = new  JoinedStringAst(parent());
-                nodeStack.push(v); v->values = visitNodeList<_expr, ExpressionAst>(node->v.JoinedStr.values); nodeStack.pop();
-                result = v;
-                break;
-            }
-#endif
-#if PYTHON_VERSION >= QT_VERSION_CHECK(3, 6, 0)
-        case FormattedValue_kind: {
-                FormattedValueAst* v = new  FormattedValueAst(parent());
-                nodeStack.push(v); v->value = static_cast<ExpressionAst*>(visitNode(node->v.FormattedValue.value)); nodeStack.pop();
-                v->conversion = node->v.FormattedValue.conversion;
-                nodeStack.push(v); v->formatSpec = static_cast<ExpressionAst*>(visitNode(node->v.FormattedValue.format_spec)); nodeStack.pop();
-                result = v;
-                break;
-            }
-#endif
-#if PYTHON_VERSION < QT_VERSION_CHECK(3, 8, 0)
-        case Bytes_kind: {
-                BytesAst* v = new  BytesAst(parent());
-                v->value = PyUnicodeObjectToQString(node->v.Bytes.s);
-                result = v;
-                break;
-            }
-#endif
-        case Attribute_kind: {
-                AttributeAst* v = new  AttributeAst(parent());
-                v->attribute = node->v.Attribute.attr ? new Python::Identifier(PyUnicodeObjectToQString(node->v.Attribute.attr)) : nullptr;
-                if ( v->attribute ) {
-                    v->attribute->startCol = node->col_offset; v->startCol = v->attribute->startCol;
-                    v->attribute->startLine = tline(node->lineno - 1);  v->startLine = v->attribute->startLine;
-                    v->attribute->endCol = node->col_offset + v->attribute->value.length() - 1;  v->endCol = v->attribute->endCol;
-                    v->attribute->endLine = tline(node->lineno - 1);  v->endLine = v->attribute->endLine;
-                    ranges_copied = true;
-                }
-                nodeStack.push(v); v->value = static_cast<ExpressionAst*>(visitNode(node->v.Attribute.value)); nodeStack.pop();
-                v->context = (ExpressionAst::Context) node->v.Attribute.ctx;
-                result = v;
-                break;
-            }
-        case Subscript_kind: {
-                SubscriptAst* v = new  SubscriptAst(parent());
-                nodeStack.push(v); v->value = static_cast<ExpressionAst*>(visitNode(node->v.Subscript.value)); nodeStack.pop();
-                nodeStack.push(v); v->slice = static_cast<SliceAst*>(visitNode(node->v.Subscript.slice)); nodeStack.pop();
-                v->context = (ExpressionAst::Context) node->v.Subscript.ctx;
-                result = v;
-                break;
-            }
-        case Starred_kind: {
-                StarredAst* v = new  StarredAst(parent());
-                nodeStack.push(v); v->value = static_cast<ExpressionAst*>(visitNode(node->v.Starred.value)); nodeStack.pop();
-                v->context = (ExpressionAst::Context) node->v.Starred.ctx;
-                result = v;
-                break;
-            }
-        case Name_kind: {
-                NameAst* v = new  NameAst(parent());
-                v->identifier = node->v.Name.id ? new Python::Identifier(PyUnicodeObjectToQString(node->v.Name.id)) : nullptr;
-                if ( v->identifier ) {
-                    v->identifier->startCol = node->col_offset; v->startCol = v->identifier->startCol;
-                    v->identifier->startLine = tline(node->lineno - 1);  v->startLine = v->identifier->startLine;
-                    v->identifier->endCol = node->col_offset + v->identifier->value.length() - 1;  v->endCol = v->identifier->endCol;
-                    v->identifier->endLine = tline(node->lineno - 1);  v->endLine = v->identifier->endLine;
-                    ranges_copied = true;
-                }
-                v->context = (ExpressionAst::Context) node->v.Name.ctx;
-                result = v;
-                break;
-            }
-        case List_kind: {
-                ListAst* v = new  ListAst(parent());
-                nodeStack.push(v); v->elements = visitNodeList<_expr, ExpressionAst>(node->v.List.elts); nodeStack.pop();
-                v->context = (ExpressionAst::Context) node->v.List.ctx;
-                result = v;
-                break;
-            }
-        case Tuple_kind: {
-                TupleAst* v = new  TupleAst(parent());
-                nodeStack.push(v); v->elements = visitNodeList<_expr, ExpressionAst>(node->v.Tuple.elts); nodeStack.pop();
-                v->context = (ExpressionAst::Context) node->v.Tuple.ctx;
-                result = v;
-                break;
-            }
-#if PYTHON_VERSION < QT_VERSION_CHECK(3, 8, 0)
-        case Ellipsis_kind: {
-                EllipsisAst* v = new  EllipsisAst(parent());
-                result = v;
-                break;
-            }
-#endif
-#if PYTHON_VERSION < QT_VERSION_CHECK(3, 8, 0)
-        case NameConstant_kind: {
-                NameConstantAst* v = new  NameConstantAst(parent());
-                v->value = node->v.NameConstant.value == Py_None ? NameConstantAst::None : node->v.NameConstant.value == Py_False ? NameConstantAst::False : NameConstantAst::True;
-                result = v;
-                break;
-            }
-#endif
-        case YieldFrom_kind: {
-                YieldFromAst* v = new  YieldFromAst(parent());
-                nodeStack.push(v); v->value = static_cast<ExpressionAst*>(visitNode(node->v.YieldFrom.value)); nodeStack.pop();
-                result = v;
-                break;
-            }
-#if PYTHON_VERSION >= QT_VERSION_CHECK(3, 8, 0)
-        case Constant_kind: {
-PyObject *value = node->v.Constant.value;if (value == Py_None) {    NameConstantAst* v = new NameConstantAst(parent());    v->value = NameConstantAst::None;    result = v;}else if (value == Py_True) {    NameConstantAst* v = new  NameConstantAst(parent());    v->value = NameConstantAst::True;    result = v;}else if (value == Py_False) {    NameConstantAst* v = new  NameConstantAst(parent());    v->value = NameConstantAst::False;    result = v;}else if (value->ob_type == &PyLong_Type) {    NumberAst* v = new NumberAst(parent());    v->isInt = true;    v->value = PyLong_AsLong(value);    result = v;}else if (value->ob_type == &PyFloat_Type || value->ob_type == &PyComplex_Type) {    result = new NumberAst(parent());}else if (value->ob_type == &PyUnicode_Type) {    StringAst* v = new StringAst(parent());    v->value = PyUnicodeObjectToQString(value);    result = v;}else if (value->ob_type == &PyBytes_Type) {    result = new BytesAst(parent());}else if (value->ob_type == &PyEllipsis_Type) {    result = new EllipsisAst(parent());}else {    qWarning() << "Unhandled constant type: " << value->ob_type->tp_name;    Q_ASSERT(false);};
-                break;
-            }
-#endif
-#if PYTHON_VERSION >= QT_VERSION_CHECK(3, 8, 0)
-        case NamedExpr_kind: {
-                AssignmentExpressionAst* v = new  AssignmentExpressionAst(parent());
-                nodeStack.push(v); v->target = static_cast<ExpressionAst*>(visitNode(node->v.NamedExpr.target)); nodeStack.pop();
-                nodeStack.push(v); v->value = static_cast<ExpressionAst*>(visitNode(node->v.NamedExpr.value)); nodeStack.pop();
-                result = v;
-                break;
-            }
-#endif
-#if PYTHON_VERSION >= QT_VERSION_CHECK(3, 9, 0)
-        case Slice_kind: {
-                SliceAst* v = new  SliceAst(parent());
-                nodeStack.push(v); v->lower = static_cast<ExpressionAst*>(visitNode(node->v.Slice.lower)); nodeStack.pop();
-                nodeStack.push(v); v->upper = static_cast<ExpressionAst*>(visitNode(node->v.Slice.upper)); nodeStack.pop();
-                nodeStack.push(v); v->step = static_cast<ExpressionAst*>(visitNode(node->v.Slice.step)); nodeStack.pop();
-                result = v;
-                break;
-            }
-#endif
-        default:
-            qWarning() << "Unsupported _expr AST type: " << node->kind;
-            Q_ASSERT(false);
-        }
-
-	if ( ! result ) return nullptr;
-        if ( ! ranges_copied ) {
-            result->startCol = node->col_offset;
-            result->endCol = node->col_offset;
-            result->startLine = tline(node->lineno - 1);
-            result->endLine = tline(node->lineno - 1);
-            result->hasUsefulRangeInformation = true;
-        }
-        else {
-            result->hasUsefulRangeInformation = true;
-        }
-        
-        // Walk through the tree and set proper end columns and lines, as the python parser sadly does not do this for us
-        if ( result->hasUsefulRangeInformation ) {
-            Ast* parent = result->parent;
-            while ( parent ) {
-                if ( parent->endLine < result->endLine ) {
-                    parent->endLine = result->endLine;
-                    parent->endCol = result->endCol;
-                }
-                if ( ! parent->hasUsefulRangeInformation && parent->startLine == -99999 ) {
-                    parent->startLine = result->startLine;
-                    parent->startCol = result->startCol;
-                }
-                parent = parent->parent;
-            }
-        }
-    
-        if ( result && result->astType == Ast::NameAstType ) {
-            NameAst* r = static_cast<NameAst*>(result);
-            r->startCol = r->identifier->startCol;
-            r->endCol = r->identifier->endCol;
-            r->startLine = r->identifier->startLine;
-            r->endLine = r->identifier->endLine;
-        }
-        return result;
-    }
-
-
-    Ast* visitNode(_keyword* node) {
-        bool ranges_copied = false; Q_UNUSED(ranges_copied);
-        if ( ! node ) return nullptr;
-                KeywordAst* v = new  KeywordAst(parent());
-            v->argumentName = node->arg ? new Python::Identifier(PyUnicodeObjectToQString(node->arg)) : nullptr;
-            nodeStack.push(v); v->value = static_cast<ExpressionAst*>(visitNode(node->value)); nodeStack.pop();
-        return v;
-    }
-
-#if PYTHON_VERSION < QT_VERSION_CHECK(3, 9, 0)
-
-    Ast* visitNode(_slice* node) {
-        if ( ! node ) return nullptr;
-        bool ranges_copied = false; Q_UNUSED(ranges_copied);
-        Ast* result = nullptr;
-        switch ( node->kind ) {
-#if PYTHON_VERSION < QT_VERSION_CHECK(3, 9, 0)
-        case Slice_kind: {
-                SliceAst* v = new  SliceAst(parent());
-                nodeStack.push(v); v->lower = static_cast<ExpressionAst*>(visitNode(node->v.Slice.lower)); nodeStack.pop();
-                nodeStack.push(v); v->upper = static_cast<ExpressionAst*>(visitNode(node->v.Slice.upper)); nodeStack.pop();
-                nodeStack.push(v); v->step = static_cast<ExpressionAst*>(visitNode(node->v.Slice.step)); nodeStack.pop();
-                result = v;
-                break;
-            }
-#endif
-#if PYTHON_VERSION < QT_VERSION_CHECK(3, 9, 0)
-        case ExtSlice_kind: {
-                TupleAst* v = new  TupleAst(parent());
-                nodeStack.push(v); v->elements = visitNodeList<_slice, ExpressionAst>(node->v.ExtSlice.dims); nodeStack.pop();
-                result = v;
-                break;
-            }
-#endif
-#if PYTHON_VERSION < QT_VERSION_CHECK(3, 9, 0)
-        case Index_kind: {
- return visitNode(node->v.Index.value);
-                break;
-            }
-#endif
-        default:
-            qWarning() << "Unsupported _slice AST type: " << node->kind;
-            Q_ASSERT(false);
-        }
-
-        // Walk through the tree and set proper end columns and lines, as the python parser sadly does not do this for us
-        if ( result->hasUsefulRangeInformation ) {
-            Ast* parent = result->parent;
-            while ( parent ) {
-                if ( parent->endLine < result->endLine ) {
-                    parent->endLine = result->endLine;
-                    parent->endCol = result->endCol;
-                }
-                if ( ! parent->hasUsefulRangeInformation && parent->startLine == -99999 ) {
-                    parent->startLine = result->startLine;
-                    parent->startCol = result->startCol;
-                }
-                parent = parent->parent;
-            }
-        }
-    
-        if ( result && result->astType == Ast::NameAstType ) {
-            NameAst* r = static_cast<NameAst*>(result);
-            r->startCol = r->identifier->startCol;
-            r->endCol = r->identifier->endCol;
-            r->startLine = r->identifier->startLine;
-            r->endLine = r->identifier->endLine;
-        }
-        return result;
-    }
-
-#endif
-
-
-    Ast* visitNode(_stmt* node) {
-        if ( ! node ) return nullptr;
-        bool ranges_copied = false; Q_UNUSED(ranges_copied);
-        Ast* result = nullptr;
-        switch ( node->kind ) {
-        case Expr_kind: {
-                ExpressionAst* v = new  ExpressionAst(parent());
-                nodeStack.push(v); v->value = static_cast<ExpressionAst*>(visitNode(node->v.Expr.value)); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case FunctionDef_kind: {
-                FunctionDefinitionAst* v = new  FunctionDefinitionAst(parent());
-                v->name = node->v.FunctionDef.name ? new Python::Identifier(PyUnicodeObjectToQString(node->v.FunctionDef.name)) : nullptr;
-                if ( v->name ) {
-                    v->name->startCol = node->col_offset; v->startCol = v->name->startCol;
-                    v->name->startLine = tline(node->lineno - 1);  v->startLine = v->name->startLine;
-                    v->name->endCol = node->col_offset + v->name->value.length() - 1;  v->endCol = v->name->endCol;
-                    v->name->endLine = tline(node->lineno - 1);  v->endLine = v->name->endLine;
-                    ranges_copied = true;
-                }
-                nodeStack.push(v); v->arguments = static_cast<ArgumentsAst*>(visitNode(node->v.FunctionDef.args)); nodeStack.pop();
-                nodeStack.push(v); v->body = visitNodeList<_stmt, Ast>(node->v.FunctionDef.body); nodeStack.pop();
-                nodeStack.push(v); v->decorators = visitNodeList<_expr, ExpressionAst>(node->v.FunctionDef.decorator_list); nodeStack.pop();
-                nodeStack.push(v); v->returns = static_cast<ExpressionAst*>(visitNode(node->v.FunctionDef.returns)); nodeStack.pop();
-                result = v;
-                break;
-            }
-#if PYTHON_VERSION >= QT_VERSION_CHECK(3, 5, 0)
-        case AsyncFunctionDef_kind: {
-                FunctionDefinitionAst* v = new  FunctionDefinitionAst(parent());
-                v->name = node->v.AsyncFunctionDef.name ? new Python::Identifier(PyUnicodeObjectToQString(node->v.AsyncFunctionDef.name)) : nullptr;
-                if ( v->name ) {
-                    v->name->startCol = node->col_offset; v->startCol = v->name->startCol;
-                    v->name->startLine = tline(node->lineno - 1);  v->startLine = v->name->startLine;
-                    v->name->endCol = node->col_offset + v->name->value.length() - 1;  v->endCol = v->name->endCol;
-                    v->name->endLine = tline(node->lineno - 1);  v->endLine = v->name->endLine;
-                    ranges_copied = true;
-                }
-                nodeStack.push(v); v->arguments = static_cast<ArgumentsAst*>(visitNode(node->v.AsyncFunctionDef.args)); nodeStack.pop();
-                nodeStack.push(v); v->body = visitNodeList<_stmt, Ast>(node->v.AsyncFunctionDef.body); nodeStack.pop();
-                nodeStack.push(v); v->decorators = visitNodeList<_expr, ExpressionAst>(node->v.AsyncFunctionDef.decorator_list); nodeStack.pop();
-                nodeStack.push(v); v->returns = static_cast<ExpressionAst*>(visitNode(node->v.AsyncFunctionDef.returns)); nodeStack.pop();
- v->async = true;
-                result = v;
-                break;
-            }
-#endif
-        case ClassDef_kind: {
-                ClassDefinitionAst* v = new  ClassDefinitionAst(parent());
-                v->name = node->v.ClassDef.name ? new Python::Identifier(PyUnicodeObjectToQString(node->v.ClassDef.name)) : nullptr;
-                if ( v->name ) {
-                    v->name->startCol = node->col_offset; v->startCol = v->name->startCol;
-                    v->name->startLine = tline(node->lineno - 1);  v->startLine = v->name->startLine;
-                    v->name->endCol = node->col_offset + v->name->value.length() - 1;  v->endCol = v->name->endCol;
-                    v->name->endLine = tline(node->lineno - 1);  v->endLine = v->name->endLine;
-                    ranges_copied = true;
-                }
-                nodeStack.push(v); v->baseClasses = visitNodeList<_expr, ExpressionAst>(node->v.ClassDef.bases); nodeStack.pop();
-                nodeStack.push(v); v->body = visitNodeList<_stmt, Ast>(node->v.ClassDef.body); nodeStack.pop();
-                nodeStack.push(v); v->decorators = visitNodeList<_expr, ExpressionAst>(node->v.ClassDef.decorator_list); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case Return_kind: {
-                ReturnAst* v = new  ReturnAst(parent());
-                nodeStack.push(v); v->value = static_cast<ExpressionAst*>(visitNode(node->v.Return.value)); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case Delete_kind: {
-                DeleteAst* v = new  DeleteAst(parent());
-                nodeStack.push(v); v->targets = visitNodeList<_expr, ExpressionAst>(node->v.Delete.targets); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case Assign_kind: {
-                AssignmentAst* v = new  AssignmentAst(parent());
-                nodeStack.push(v); v->targets = visitNodeList<_expr, ExpressionAst>(node->v.Assign.targets); nodeStack.pop();
-                nodeStack.push(v); v->value = static_cast<ExpressionAst*>(visitNode(node->v.Assign.value)); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case AugAssign_kind: {
-                AugmentedAssignmentAst* v = new  AugmentedAssignmentAst(parent());
-                nodeStack.push(v); v->target = static_cast<ExpressionAst*>(visitNode(node->v.AugAssign.target)); nodeStack.pop();
-                v->op = (ExpressionAst::OperatorTypes) node->v.AugAssign.op;
-                nodeStack.push(v); v->value = static_cast<ExpressionAst*>(visitNode(node->v.AugAssign.value)); nodeStack.pop();
-                result = v;
-                break;
-            }
-#if PYTHON_VERSION >= QT_VERSION_CHECK(3, 6, 0)
-        case AnnAssign_kind: {
-                AnnotationAssignmentAst* v = new  AnnotationAssignmentAst(parent());
-                nodeStack.push(v); v->target = static_cast<ExpressionAst*>(visitNode(node->v.AnnAssign.target)); nodeStack.pop();
-                nodeStack.push(v); v->annotation = static_cast<ExpressionAst*>(visitNode(node->v.AnnAssign.annotation)); nodeStack.pop();
-                nodeStack.push(v); v->value = static_cast<ExpressionAst*>(visitNode(node->v.AnnAssign.value)); nodeStack.pop();
-                result = v;
-                break;
-            }
-#endif
-        case For_kind: {
-                ForAst* v = new  ForAst(parent());
-                nodeStack.push(v); v->target = static_cast<ExpressionAst*>(visitNode(node->v.For.target)); nodeStack.pop();
-                nodeStack.push(v); v->iterator = static_cast<ExpressionAst*>(visitNode(node->v.For.iter)); nodeStack.pop();
-                nodeStack.push(v); v->body = visitNodeList<_stmt, Ast>(node->v.For.body); nodeStack.pop();
-                nodeStack.push(v); v->orelse = visitNodeList<_stmt, Ast>(node->v.For.orelse); nodeStack.pop();
-                result = v;
-                break;
-            }
-#if PYTHON_VERSION >= QT_VERSION_CHECK(3, 5, 0)
-        case AsyncFor_kind: {
-                ForAst* v = new  ForAst(parent());
-                nodeStack.push(v); v->target = static_cast<ExpressionAst*>(visitNode(node->v.AsyncFor.target)); nodeStack.pop();
-                nodeStack.push(v); v->iterator = static_cast<ExpressionAst*>(visitNode(node->v.AsyncFor.iter)); nodeStack.pop();
-                nodeStack.push(v); v->body = visitNodeList<_stmt, Ast>(node->v.AsyncFor.body); nodeStack.pop();
-                nodeStack.push(v); v->orelse = visitNodeList<_stmt, Ast>(node->v.AsyncFor.orelse); nodeStack.pop();
-                result = v;
-                break;
-            }
-#endif
-        case While_kind: {
-                WhileAst* v = new  WhileAst(parent());
-                nodeStack.push(v); v->condition = static_cast<ExpressionAst*>(visitNode(node->v.While.test)); nodeStack.pop();
-                nodeStack.push(v); v->body = visitNodeList<_stmt, Ast>(node->v.While.body); nodeStack.pop();
-                nodeStack.push(v); v->orelse = visitNodeList<_stmt, Ast>(node->v.While.orelse); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case If_kind: {
-                IfAst* v = new  IfAst(parent());
-                nodeStack.push(v); v->condition = static_cast<ExpressionAst*>(visitNode(node->v.If.test)); nodeStack.pop();
-                nodeStack.push(v); v->body = visitNodeList<_stmt, Ast>(node->v.If.body); nodeStack.pop();
-                nodeStack.push(v); v->orelse = visitNodeList<_stmt, Ast>(node->v.If.orelse); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case With_kind: {
-                WithAst* v = new  WithAst(parent());
-                nodeStack.push(v); v->body = visitNodeList<_stmt, Ast>(node->v.With.body); nodeStack.pop();
-                nodeStack.push(v); v->items = visitNodeList<_withitem, WithItemAst>(node->v.With.items); nodeStack.pop();
-                result = v;
-                break;
-            }
-#if PYTHON_VERSION >= QT_VERSION_CHECK(3, 5, 0)
-        case AsyncWith_kind: {
-                WithAst* v = new  WithAst(parent());
-                nodeStack.push(v); v->body = visitNodeList<_stmt, Ast>(node->v.AsyncWith.body); nodeStack.pop();
-                nodeStack.push(v); v->items = visitNodeList<_withitem, WithItemAst>(node->v.AsyncWith.items); nodeStack.pop();
-                result = v;
-                break;
-            }
-#endif
-        case Raise_kind: {
-                RaiseAst* v = new  RaiseAst(parent());
-                nodeStack.push(v); v->type = static_cast<ExpressionAst*>(visitNode(node->v.Raise.exc)); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case Try_kind: {
-                TryAst* v = new  TryAst(parent());
-                nodeStack.push(v); v->body = visitNodeList<_stmt, Ast>(node->v.Try.body); nodeStack.pop();
-                nodeStack.push(v); v->handlers = visitNodeList<_excepthandler, ExceptionHandlerAst>(node->v.Try.handlers); nodeStack.pop();
-                nodeStack.push(v); v->orelse = visitNodeList<_stmt, Ast>(node->v.Try.orelse); nodeStack.pop();
-                nodeStack.push(v); v->finally = visitNodeList<_stmt, Ast>(node->v.Try.finalbody); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case Assert_kind: {
-                AssertionAst* v = new  AssertionAst(parent());
-                nodeStack.push(v); v->condition = static_cast<ExpressionAst*>(visitNode(node->v.Assert.test)); nodeStack.pop();
-                nodeStack.push(v); v->message = static_cast<ExpressionAst*>(visitNode(node->v.Assert.msg)); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case Import_kind: {
-                ImportAst* v = new  ImportAst(parent());
-                nodeStack.push(v); v->names = visitNodeList<_alias, AliasAst>(node->v.Import.names); nodeStack.pop();
-                result = v;
-                break;
-            }
-        case ImportFrom_kind: {
-                ImportFromAst* v = new  ImportFromAst(parent());
-                v->module = node->v.ImportFrom.module ? new Python::Identifier(PyUnicodeObjectToQString(node->v.ImportFrom.module)) : nullptr;
-                if ( v->module ) {
-                    v->module->startCol = node->col_offset; v->startCol = v->module->startCol;
-                    v->module->startLine = tline(node->lineno - 1);  v->startLine = v->module->startLine;
-                    v->module->endCol = node->col_offset + v->module->value.length() - 1;  v->endCol = v->module->endCol;
-                    v->module->endLine = tline(node->lineno - 1);  v->endLine = v->module->endLine;
-                    ranges_copied = true;
-                }
-                nodeStack.push(v); v->names = visitNodeList<_alias, AliasAst>(node->v.ImportFrom.names); nodeStack.pop();
-                v->level = node->v.ImportFrom.level;
-                result = v;
-                break;
-            }
-        case Global_kind: {
-                GlobalAst* v = new  GlobalAst(parent());
-
-                for ( int _i = 0; _i < node->v.Global.names->size; _i++ ) {
-                    Python::Identifier* id = new Python::Identifier(PyUnicodeObjectToQString(
-                                    static_cast<PyObject*>(node->v.Global.names->elements[_i])
-                            ));
-                    v->names.append(id);
-                }
-
-                result = v;
-                break;
-            }
-        case Break_kind: {
-                BreakAst* v = new  BreakAst(parent());
-                result = v;
-                break;
-            }
-        case Continue_kind: {
-                ContinueAst* v = new  ContinueAst(parent());
-                result = v;
-                break;
-            }
-        case Pass_kind: {
-                PassAst* v = new  PassAst(parent());
-                result = v;
-                break;
-            }
-        case Nonlocal_kind: {
-                NonlocalAst* v = new  NonlocalAst(parent());
-                result = v;
-                break;
-            }
-        default:
-            qWarning() << "Unsupported _stmt AST type: " << node->kind;
-            Q_ASSERT(false);
-        }
-
-	if ( ! result ) return nullptr;
-        if ( ! ranges_copied ) {
-            result->startCol = node->col_offset;
-            result->endCol = node->col_offset;
-            result->startLine = tline(node->lineno - 1);
-            result->endLine = tline(node->lineno - 1);
-            result->hasUsefulRangeInformation = true;
-        }
-        else {
-            result->hasUsefulRangeInformation = true;
-        }
-        
-        // Walk through the tree and set proper end columns and lines, as the python parser sadly does not do this for us
-        if ( result->hasUsefulRangeInformation ) {
-            Ast* parent = result->parent;
-            while ( parent ) {
-                if ( parent->endLine < result->endLine ) {
-                    parent->endLine = result->endLine;
-                    parent->endCol = result->endCol;
-                }
-                if ( ! parent->hasUsefulRangeInformation && parent->startLine == -99999 ) {
-                    parent->startLine = result->startLine;
-                    parent->startCol = result->startCol;
-                }
-                parent = parent->parent;
-            }
-        }
-    
-        if ( result && result->astType == Ast::NameAstType ) {
-            NameAst* r = static_cast<NameAst*>(result);
-            r->startCol = r->identifier->startCol;
-            r->endCol = r->identifier->endCol;
-            r->startLine = r->identifier->startLine;
-            r->endLine = r->identifier->endLine;
-        }
-        return result;
-    }
-
-
-    Ast* visitNode(_withitem* node) {
-        bool ranges_copied = false; Q_UNUSED(ranges_copied);
-        if ( ! node ) return nullptr;
-                WithItemAst* v = new  WithItemAst(parent());
-            nodeStack.push(v); v->contextExpression = static_cast<ExpressionAst*>(visitNode(node->context_expr)); nodeStack.pop();
-            nodeStack.push(v); v->optionalVars = static_cast<ExpressionAst*>(visitNode(node->optional_vars)); nodeStack.pop();
-        return v;
-    }
-
-};
-
-/*
- * End generated code
- */
-
diff --git a/parser/python310.sdef b/parser/python310.sdef
deleted file mode 100644
index 38d7da9c..00000000
--- a/parser/python310.sdef
+++ /dev/null
@@ -1,147 +0,0 @@
-COMMENT;This file specifies rules for a conversion of a python (C) to a plugin-internal (C++) syntax tree;;
-COMMENT;All lines are terminated by a double semicolon token, newlines are ignored.;;
-COMMENT;-> stands for "convert AST", => for "convert AST list", ~> for "make an identifier", :> is an assignment w/o conversion, and *> is an enum cast.;;
-COMMENT;$> is a string assignment, +> is a "mindless assignment, like, it just does v->arg = node->arg.
-COMMENT;_> is a Singleton Assignment (converts Py_True, Py_False, Py_None to enum)
-COMMENT;the CODE statement can be used to add custom code.;;
-
-
-RULE_FOR _stmt;KIND Expr_kind;ACTIONS create|ExpressionAst set|value->ExpressionAst,value;;
-RULE_FOR _stmt;KIND FunctionDef_kind;ACTIONS create|FunctionDefinitionAst set|name~>name set|arguments->ArgumentsAst,args
-    set|body=>Ast,body set|decorators=>ExpressionAst,decorator_list set|returns->ExpressionAst,returns;;
-RULE_FOR _stmt;KIND AsyncFunctionDef_kind;ACTIONS create|FunctionDefinitionAst set|name~>name set|arguments->ArgumentsAst,args
-    set|body=>Ast,body set|decorators=>ExpressionAst,decorator_list set|returns->ExpressionAst,returns;SINCE 3.5;CODE v->async = true;;
-RULE_FOR _stmt;KIND ClassDef_kind;ACTIONS create|ClassDefinitionAst set|name~>name set|baseClasses=>ExpressionAst,bases set|body=>Ast,body
-    set|decorators=>ExpressionAst,decorator_list;;
-RULE_FOR _stmt;KIND Return_kind;ACTIONS create|ReturnAst set|value->ExpressionAst,value;;
-RULE_FOR _stmt;KIND Delete_kind;ACTIONS create|DeleteAst set|targets=>ExpressionAst,targets;;
-RULE_FOR _stmt;KIND Assign_kind;ACTIONS create|AssignmentAst set|targets=>ExpressionAst,targets set|value->ExpressionAst,value;;
-RULE_FOR _stmt;KIND AugAssign_kind;ACTIONS create|AugmentedAssignmentAst set|target->ExpressionAst,target set|op*>OperatorTypes,op set|value->ExpressionAst,value;;
-RULE_FOR _stmt;KIND AnnAssign_kind;ACTIONS create|AnnotationAssignmentAst set|target->ExpressionAst,target set|annotation->ExpressionAst,annotation set|value->ExpressionAst,value;SINCE 3.6;;
-RULE_FOR _stmt;KIND For_kind;ACTIONS create|ForAst set|target->ExpressionAst,target set|iterator->ExpressionAst,iter set|body=>Ast,body set|orelse=>Ast,orelse;;
-RULE_FOR _stmt;KIND AsyncFor_kind;ACTIONS create|ForAst set|target->ExpressionAst,target set|iterator->ExpressionAst,iter set|body=>Ast,body set|orelse=>Ast,orelse;SINCE 3.5;;
-RULE_FOR _stmt;KIND While_kind;ACTIONS create|WhileAst set|condition->ExpressionAst,test set|body=>Ast,body set|orelse=>Ast,orelse;;
-RULE_FOR _stmt;KIND If_kind;ACTIONS create|IfAst set|condition->ExpressionAst,test set|body=>Ast,body set|orelse=>Ast,orelse;;
-RULE_FOR _stmt;KIND With_kind;ACTIONS create|WithAst set|body=>Ast,body set|items=>WithItemAst,items;;
-RULE_FOR _stmt;KIND AsyncWith_kind;ACTIONS create|WithAst set|body=>Ast,body set|items=>WithItemAst,items;SINCE 3.5;;
-
-COMMENT;FIXME: the struct Raise has changed, so the following line is likely wrong;;
-RULE_FOR _stmt;KIND Raise_kind;ACTIONS create|RaiseAst set|type->ExpressionAst,exc;;
-RULE_FOR _stmt;KIND Try_kind;ACTIONS create|TryAst set|body=>Ast,body set|handlers=>ExceptionHandlerAst,handlers set|orelse=>Ast,orelse set|finally=>Ast,finalbody;;
-RULE_FOR _stmt;KIND Assert_kind;ACTIONS create|AssertionAst set|condition->ExpressionAst,test set|message->ExpressionAst,msg;;
-RULE_FOR _stmt;KIND Import_kind;ACTIONS create|ImportAst set|names=>AliasAst,names;;
-RULE_FOR _stmt;KIND ImportFrom_kind;ACTIONS create|ImportFromAst set|module~>module set|names=>AliasAst,names set|level:>level;;
-RULE_FOR _stmt;KIND Global_kind;ACTIONS create|GlobalAst set|names=>Identifier,names;;
-RULE_FOR _stmt;KIND Break_kind;ACTIONS create|BreakAst;;
-RULE_FOR _stmt;KIND Continue_kind;ACTIONS create|ContinueAst;;
-RULE_FOR _stmt;KIND Pass_kind;ACTIONS create|PassAst;;
-RULE_FOR _stmt;KIND Nonlocal_kind;ACTIONS create|NonlocalAst;;
-
-RULE_FOR _expr;KIND Await_kind;ACTIONS create|AwaitAst set|value->ExpressionAst,value;SINCE 3.5;;
-RULE_FOR _expr;KIND BoolOp_kind;ACTIONS create|BooleanOperationAst set|type*>BooleanOperationTypes,op set|values=>ExpressionAst,values;;
-RULE_FOR _expr;KIND BinOp_kind;ACTIONS create|BinaryOperationAst set|type*>OperatorTypes,op set|lhs->ExpressionAst,left set|rhs->ExpressionAst,right;;
-RULE_FOR _expr;KIND UnaryOp_kind;ACTIONS create|UnaryOperationAst set|type*>UnaryOperatorTypes,op set|operand->ExpressionAst,operand;;
-RULE_FOR _expr;KIND Lambda_kind;ACTIONS create|LambdaAst set|arguments->ArgumentsAst,args set|body->ExpressionAst,body;;
-RULE_FOR _expr;KIND IfExp_kind;ACTIONS create|IfExpressionAst set|condition->ExpressionAst,test set|body->ExpressionAst,body set|orelse->ExpressionAst,orelse;;
-RULE_FOR _expr;KIND Dict_kind;ACTIONS create|DictAst set|keys=>ExpressionAst,keys set|values=>ExpressionAst,values;;
-RULE_FOR _expr;KIND Set_kind;ACTIONS create|SetAst set|elements=>ExpressionAst,elts;;
-RULE_FOR _expr;KIND ListComp_kind;ACTIONS create|ListComprehensionAst set|element->ExpressionAst,elt set|generators=>ComprehensionAst,generators;;
-RULE_FOR _expr;KIND SetComp_kind;ACTIONS create|SetComprehensionAst set|element->ExpressionAst,elt set|generators=>ComprehensionAst,generators;;
-RULE_FOR _expr;KIND DictComp_kind;ACTIONS create|DictionaryComprehensionAst set|key->ExpressionAst,key set|value->ExpressionAst,value set|generators=>ComprehensionAst,generators;;
-RULE_FOR _expr;KIND GeneratorExp_kind;ACTIONS create|GeneratorExpressionAst set|element->ExpressionAst,elt set|generators=>ComprehensionAst,generators;;
-RULE_FOR _expr;KIND Yield_kind;ACTIONS create|YieldAst set|value->ExpressionAst,value;;
-RULE_FOR _expr;KIND Compare_kind;ACTIONS create|CompareAst set|leftmostElement->ExpressionAst,left set|operators#>ComparisonOperatorTypes,ops set|comparands=>ExpressionAst,comparators;;
-RULE_FOR _expr;KIND Call_kind;ACTIONS create|CallAst set|function->ExpressionAst,func set|arguments=>ExpressionAst,args set|keywords=>KeywordAst,keywords;SINCE 3.5;;
-RULE_FOR _expr;KIND Call_kind;ACTIONS create|CallAst set|function->ExpressionAst,func set|arguments=>ExpressionAst,args set|keywords=>KeywordAst,keywords;BEFORE 3.5;
-CODE /* Convert 3.4 unpacked-args AST to match the new format from 3.5+ */
-if (node->v.Call.starargs) {
-    nodeStack.push(v);
-    auto starred = new StarredAst(v);
-    starred->context = ExpressionAst::Context::Load;
-    nodeStack.push(starred);
-    starred->value = static_cast<ExpressionAst*>(visitNode(node->v.Call.starargs));
-    nodeStack.pop();
-    v->arguments.append(starred);
-    nodeStack.pop();
-};
-if (node->v.Call.kwargs) {
-    nodeStack.push(v);
-    auto kwargs = new KeywordAst(v);
-    nodeStack.push(kwargs);
-    kwargs->value = static_cast<ExpressionAst*>(visitNode(node->v.Call.kwargs));
-    nodeStack.pop();
-    v->keywords.append(kwargs);
-    nodeStack.pop();
-};;
-RULE_FOR _expr;KIND Num_kind;ACTIONS create|NumberAst;BEFORE 3.8;CODE v->isInt = PyLong_Check(node->v.Num.n); v->value = PyLong_AsLong(node->v.Num.n);;
-RULE_FOR _expr;KIND Str_kind;ACTIONS create|StringAst set|value$>s;BEFORE 3.8;;
-RULE_FOR _expr;KIND JoinedStr_kind;ACTIONS create|JoinedStringAst set|values=>ExpressionAst,values;SINCE 3.6;;
-RULE_FOR _expr;KIND FormattedValue_kind;ACTIONS create|FormattedValueAst set|value->ExpressionAst,value set|conversion:>conversion set|formatSpec->ExpressionAst,format_spec;SINCE 3.6;;
-RULE_FOR _expr;KIND Bytes_kind;ACTIONS create|BytesAst set|value$>s;BEFORE 3.8;;
-RULE_FOR _expr;KIND Attribute_kind;ACTIONS create|AttributeAst set|attribute~>attr set|value->ExpressionAst,value set|context*>Context,ctx;;
-RULE_FOR _expr;KIND Subscript_kind;ACTIONS create|SubscriptAst set|value->ExpressionAst,value set|slice->SliceAst,slice set|context*>Context,ctx;;
-RULE_FOR _expr;KIND Starred_kind;ACTIONS create|StarredAst set|value->ExpressionAst,value set|context*>Context,ctx;;
-RULE_FOR _expr;KIND Name_kind;ACTIONS create|NameAst set|identifier~>id set|context*>Context,ctx;;
-RULE_FOR _expr;KIND List_kind;ACTIONS create|ListAst set|elements=>ExpressionAst,elts set|context*>Context,ctx;;
-RULE_FOR _expr;KIND Tuple_kind;ACTIONS create|TupleAst set|elements=>ExpressionAst,elts set|context*>Context,ctx;;
-RULE_FOR _expr;KIND Ellipsis_kind;ACTIONS create|EllipsisAst;BEFORE 3.8;;
-RULE_FOR _expr;KIND NameConstant_kind;ACTIONS create|NameConstantAst set|value_>value;BEFORE 3.8;;
-RULE_FOR _expr;KIND YieldFrom_kind;ACTIONS create|YieldFromAst set|value->ExpressionAst,value;;
-RULE_FOR _expr;KIND Constant_kind;ACTIONS;SINCE 3.8;CODE
-PyObject *value = node->v.Constant.value;
-if (value == Py_None) {
-    NameConstantAst* v = new NameConstantAst(parent());
-    v->value = NameConstantAst::None;
-    result = v;
-}
-else if (value == Py_True) {
-    NameConstantAst* v = new  NameConstantAst(parent());
-    v->value = NameConstantAst::True;
-    result = v;
-}
-else if (value == Py_False) {
-    NameConstantAst* v = new  NameConstantAst(parent());
-    v->value = NameConstantAst::False;
-    result = v;
-}
-else if (value->ob_type == &PyLong_Type) {
-    NumberAst* v = new NumberAst(parent());
-    v->isInt = true;
-    v->value = PyLong_AsLong(value);
-    result = v;
-}
-else if (value->ob_type == &PyFloat_Type || value->ob_type == &PyComplex_Type) {
-    result = new NumberAst(parent());
-}
-else if (value->ob_type == &PyUnicode_Type) {
-    StringAst* v = new StringAst(parent());
-    v->value = PyUnicodeObjectToQString(value);
-    result = v;
-}
-else if (value->ob_type == &PyBytes_Type) {
-    result = new BytesAst(parent());
-}
-else if (value->ob_type == &PyEllipsis_Type) {
-    result = new EllipsisAst(parent());
-}
-else {
-    qWarning() << "Unhandled constant type: " << value->ob_type->tp_name;
-    Q_ASSERT(false);
-};;
-RULE_FOR _expr;KIND NamedExpr_kind;ACTIONS create|AssignmentExpressionAst set|target->ExpressionAst,target set|value->ExpressionAst,value;SINCE 3.8;;
-RULE_FOR _expr;KIND Slice_kind;ACTIONS create|SliceAst set|lower->ExpressionAst,lower set|upper->ExpressionAst,upper set|step->ExpressionAst,step;SINCE 3.9;;
-
-RULE_FOR _slice;KIND Slice_kind;ACTIONS create|SliceAst set|lower->ExpressionAst,lower set|upper->ExpressionAst,upper set|step->ExpressionAst,step;BEFORE 3.9;;
-RULE_FOR _slice;KIND ExtSlice_kind;ACTIONS create|TupleAst;BEFORE 3.9;CODE
-                nodeStack.push(v); v->elements = visitNodeList<_slice, ExpressionAst>(node->v.ExtSlice.dims); nodeStack.pop();;
-RULE_FOR _slice;KIND Index_kind;ACTIONS;BEFORE 3.9;CODE return visitNode(node->v.Index.value);;
-
-
-RULE_FOR _comprehension;KIND any;ACTIONS create|ComprehensionAst set|target->ExpressionAst,target set|iterator->ExpressionAst,iter set|conditions=>ExpressionAst,ifs;;
-RULE_FOR _excepthandler;KIND ExceptHandler_kind;ACTIONS create|ExceptionHandlerAst set|type->ExpressionAst,type set|name~>name set|body=>Ast,body;;
-RULE_FOR _arguments;KIND any;ACTIONS create|ArgumentsAst set|vararg->ArgAst,vararg set|kwarg->ArgAst,kwarg set|arguments=>ArgAst,args set|defaultValues=>ExpressionAst,defaults set|kwonlyargs=>ArgAst,kwonlyargs;BEFORE 3.8;;
-RULE_FOR _arguments;KIND any;ACTIONS create|ArgumentsAst set|vararg->ArgAst,vararg set|kwarg->ArgAst,kwarg set|arguments=>ArgAst,args set|defaultValues=>ExpressionAst,defaults set|kwonlyargs=>ArgAst,kwonlyargs set|posonlyargs=>ArgAst,posonlyargs;SINCE 3.8;;
-RULE_FOR _arg;KIND any;ACTIONS create|ArgAst set|argumentName~>arg set|annotation->ExpressionAst,annotation;;
-RULE_FOR _keyword;KIND any;ACTIONS create|KeywordAst set|argumentName~>arg set|value->ExpressionAst,value;;
-RULE_FOR _alias;KIND any;ACTIONS create|AliasAst set|name~>name set|asName~>asname;;
-RULE_FOR _withitem;KIND any; ACTIONS create|WithItemAst set|contextExpression->ExpressionAst,context_expr set|optionalVars->ExpressionAst,optional_vars;;
-- 
GitLab


From f69fb64505f09bb5b4f3a9cbff600c36afd95fe6 Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Mon, 21 Mar 2022 10:55:35 +0100
Subject: [PATCH 24/29] avoid dependency on lxml

What we're doing xml-wise is really simple, and lxml is from experience
a difficult dependency (there are multiple variants of it and neither is
guaranteed to be available or working).
---
 parser/ast2xml.py                          | 51 ++++++++++++++++++++--
 parser/astfromxml_detail/nodereader_impl.h |  5 ++-
 2 files changed, 51 insertions(+), 5 deletions(-)

diff --git a/parser/ast2xml.py b/parser/ast2xml.py
index 67f10f1b..e7cd1b99 100644
--- a/parser/ast2xml.py
+++ b/parser/ast2xml.py
@@ -1,14 +1,49 @@
 #!/usr/bin/env python
 
 import ast
-from lxml import etree
 from io import BytesIO
+import base64
 
 import sys
 
 plain_types = (type(0), type(""), type(b""), type(0.0), type(False), type(None))
 list_type = type([])
 
+class XmlElement:
+    def __init__(self, buf, name, attrs):
+        self.buf = buf
+        self.name = name
+        self.attrs = attrs
+
+    def writestr(self, s):
+        self.buf.write(s.encode("utf-8"))
+
+    def __enter__(self):
+        self.writestr(f'<{self.name}')
+        for k, v in self.attrs.items():
+            self.writestr(f' {k}="{v}"')
+        self.writestr('>')
+        return self
+
+    def __exit__(self, type, value, tb):
+        self.writestr(f"</{self.name}>")
+
+
+class XmlStreamWriter:
+    def __init__(self, f):
+        self.buf = f
+        self.buf.write(b'<?xml version="1.0"?>')
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, type, value, tb):
+        pass
+
+    def element(self, name, attrs=dict()):
+        return XmlElement(self.buf, name, attrs)
+
+
 class ASTSerializer(ast.NodeVisitor):
     def __init__(self, xf):
         self.xf = xf
@@ -25,6 +60,10 @@ class ASTSerializer(ast.NodeVisitor):
             attrs["end_lineno"] = node.end_lineno
         if name == "Constant":
             attrs["constant_type"] = type(node.value).__name__
+            if type(node.value) == str:
+                attrs["value"] = base64.b64encode(attrs["value"].encode("utf-8"))
+            if type(node.value) == bytes:
+                attrs["value"] = base64.b64encode(attrs["value"])
         if name == "BinOp":
             attrs["op"] = type(node.op).__name__
         if name == "BoolOp":
@@ -33,7 +72,7 @@ class ASTSerializer(ast.NodeVisitor):
             attrs["op"] = type(node.op).__name__
         plain_attrs = {k: str(v) for k, v in attrs.items() if type(v) in plain_types and v is not None}
         non_plain_attrs = {k: v for k, v in attrs.items() if type(v) not in plain_types and v is not None}
-        with self.xf.element(name, **plain_attrs) as elem:
+        with self.xf.element(name, plain_attrs) as elem:
             for attr, attr_val in non_plain_attrs.items():
                 if attr == "ctx":
                     continue
@@ -64,10 +103,14 @@ def doParse(code):
 {syntaxError.msg}
 """
     except Exception as err:
-        return f"InternalError: {str(err)}"
+        import traceback
+        print(traceback.format_exc())
+        return f"InternalError: {str(err)}, {type(err)}"
 
     f = BytesIO()
-    with etree.xmlfile(f) as xf:
+    #from lxml import etree
+    #with etree.xmlfile(f) as xf:
+    with XmlStreamWriter(f) as xf:
         v = ASTSerializer(xf)
         v.visit(m)
 
diff --git a/parser/astfromxml_detail/nodereader_impl.h b/parser/astfromxml_detail/nodereader_impl.h
index 5ab75a85..60bd3638 100644
--- a/parser/astfromxml_detail/nodereader_impl.h
+++ b/parser/astfromxml_detail/nodereader_impl.h
@@ -180,7 +180,10 @@ struct NodeReader<ConstantAst> : public BaseNodeReader<ConstantAst>
             result->value = std::get<QString>(result->value).toInt();
         }
         else if (value == "bytes") {
-            result->value = std::get<QString>(result->value).toUtf8();
+            result->value = QByteArray::fromBase64(std::get<QString>(result->value).toUtf8());
+        }
+        else if (value == "str") {
+            result->value = QString::fromUtf8(QByteArray::fromBase64(std::get<QString>(result->value).toUtf8())); // phew
         }
         else if (value == "bool") {
             result->value = std::get<QString>(result->value) == "True" ? true : false;
-- 
GitLab


From c25b7aa0aaef1fd42373b632406e7279d3f7d02e Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Mon, 21 Mar 2022 10:55:46 +0100
Subject: [PATCH 25/29] fix error line number

---
 parser/astbuilder.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/parser/astbuilder.cpp b/parser/astbuilder.cpp
index 1901f719..dd105187 100644
--- a/parser/astbuilder.cpp
+++ b/parser/astbuilder.cpp
@@ -45,7 +45,7 @@ CodeAst::Ptr AstBuilder::parse(const QUrl& filename, QString &contents)
     if ( result->error ) {
         qCDebug(KDEV_PYTHON_PARSER) << " ====< parse error, trying to fix";
 
-        int lineno = result->error->line;
+        int lineno = result->error->line - 1;
         int colno = result->error->column;
 
         ProblemPointer p(new Problem());
-- 
GitLab


From 28f3f1b9f3e1a8f73a34cf40e0e9fe6ae48dcf32 Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Mon, 21 Mar 2022 10:56:08 +0100
Subject: [PATCH 26/29] only one thread may run python code at once

---
 parser/pythonrun.cpp | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/parser/pythonrun.cpp b/parser/pythonrun.cpp
index 74e72b72..828c066d 100644
--- a/parser/pythonrun.cpp
+++ b/parser/pythonrun.cpp
@@ -4,6 +4,7 @@
 
 #include <QStringList>
 #include <QFile>
+#include <QMutex>
 
 namespace {
 
@@ -53,8 +54,10 @@ public:
     }
 
     ~ParserModule() {
-        Py_DECREF(m_func);
-        Py_DECREF(m_module);
+        if (isInitialized()) {
+            Py_DECREF(m_func);
+            Py_DECREF(m_module);
+        }
         Py_Finalize();
     }
 
@@ -63,6 +66,8 @@ public:
     }
 
     std::optional<ParseResult> parse(QByteArray const& in) {
+        QMutexLocker lock(&m_lock);
+
         if (!isInitialized()) {
             qCWarning(KDEV_PYTHON_PARSER) << "Failed to initialize";
             return std::nullopt;
@@ -99,6 +104,7 @@ public:
 
     PyObject* m_module = nullptr;
     PyObject* m_func = nullptr;
+    QMutex m_lock;
 };
 
 }
-- 
GitLab


From 5e831b7653d1f5a04ee71f8a37d099c730916188 Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Mon, 21 Mar 2022 10:57:23 +0100
Subject: [PATCH 27/29] fix python from being unable to resolve its symbols
 when loaded as a plugin

See the code comment in pythonrun.cpp for details.
---
 kdevpythonversion.h.cmake |  2 ++
 parser/CMakeLists.txt     |  4 ++++
 parser/pythonrun.cpp      | 28 ++++++++++++++++++++++++++++
 3 files changed, 34 insertions(+)

diff --git a/kdevpythonversion.h.cmake b/kdevpythonversion.h.cmake
index 93181401..af1c1c2b 100644
--- a/kdevpythonversion.h.cmake
+++ b/kdevpythonversion.h.cmake
@@ -18,4 +18,6 @@
 
 #define PYTHON_EXECUTABLE "@PYTHON_EXECUTABLE@"
 
+#define PYTHON_LIBRARY "@PYTHON_LIBRARIES@"
+
 #endif
diff --git a/parser/CMakeLists.txt b/parser/CMakeLists.txt
index d0bde920..2aa42baf 100644
--- a/parser/CMakeLists.txt
+++ b/parser/CMakeLists.txt
@@ -32,6 +32,10 @@ target_link_libraries(kdevpythonparser LINK_PRIVATE
     ${PYTHON_LIBRARIES}
 )
 
+if (UNIX)
+    target_link_libraries(kdevpythonparser LINK_PRIVATE dl)
+endif()
+
 install(TARGETS kdevpythonparser DESTINATION ${INSTALL_TARGETS_DEFAULT_ARGS})
 
 if (BUILD_TESTING)
diff --git a/parser/pythonrun.cpp b/parser/pythonrun.cpp
index 828c066d..553f12d7 100644
--- a/parser/pythonrun.cpp
+++ b/parser/pythonrun.cpp
@@ -2,9 +2,16 @@
 #include "python_header.h"
 #include "parserdebug.h"
 
+#include "kdevpythonversion.h"
+
 #include <QStringList>
 #include <QFile>
 #include <QMutex>
+#include <QLibrary>
+
+#ifdef Q_OS_UNIX
+#include <dlfcn.h>
+#endif
 
 namespace {
 
@@ -33,9 +40,28 @@ std::optional<ParseError> parseErrorFromString(QByteArray const& data) {
     return ret;
 }
 
+QString pythonLibraryName() {
+    return QString::fromUtf8(PYTHON_LIBRARY).section('/', -1, -1);
+}
+
 class ParserModule {
 public:
     ParserModule() {
+#ifdef Q_OS_UNIX
+        // We are usually (outside of unit tests) loaded as a plugin. KPluginLoader
+        // loads plugins with RTLD_LOCAL (through QLibrary, but effectively it does).
+        // This means libraries our plugin links against are also loaded into the main process
+        // with RTLD_LOCAL. Thus, the symbols from libpython are *not* in the global symbol
+        // table of the process we're running in. If Python itself loads a plugin -- which easily
+        // happens for anything that "import"s a C module -- that will fail, since this plugin
+        // will not be able to find the symbols from libpython.
+        // Thus, we re-open the library here (usign RTLD_NOLOAD) to change the symbol
+        // visibility to global scope.
+        auto* lib = dlopen(pythonLibraryName().toUtf8().data(), RTLD_LAZY | RTLD_NOLOAD | RTLD_GLOBAL);
+        if (!lib)
+            qCWarning(KDEV_PYTHON_PARSER) << "Error loading libpython:" << dlerror();
+#endif
+
         Py_Initialize();
 
         m_module = PyModule_New("parser");
@@ -46,6 +72,8 @@ public:
         auto const& code = codeFile.readAll();
         auto* ret = PyRun_String(code.data(), Py_file_input, localVars, localVars);
         if (!ret) {
+            qCWarning(KDEV_PYTHON_PARSER) << "Failed to run code" << code;
+            PyErr_Print();
             return;
         }
         Py_DECREF(ret);
-- 
GitLab


From e58e78d1594e93574e0f65f286a1c9ef1aec993e Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Mon, 21 Mar 2022 11:01:08 +0100
Subject: [PATCH 28/29] fix bytes/string encoding

---
 parser/ast2xml.py                          | 4 ++--
 parser/astfromxml_detail/nodereader_impl.h | 9 +++++----
 2 files changed, 7 insertions(+), 6 deletions(-)

diff --git a/parser/ast2xml.py b/parser/ast2xml.py
index e7cd1b99..85efc95e 100644
--- a/parser/ast2xml.py
+++ b/parser/ast2xml.py
@@ -61,9 +61,9 @@ class ASTSerializer(ast.NodeVisitor):
         if name == "Constant":
             attrs["constant_type"] = type(node.value).__name__
             if type(node.value) == str:
-                attrs["value"] = base64.b64encode(attrs["value"].encode("utf-8"))
+                attrs["value"] = base64.b64encode(attrs["value"].encode("utf-8")).decode("ascii")
             if type(node.value) == bytes:
-                attrs["value"] = base64.b64encode(attrs["value"])
+                attrs["value"] = base64.b64encode(attrs["value"]).decode("ascii")
         if name == "BinOp":
             attrs["op"] = type(node.op).__name__
         if name == "BoolOp":
diff --git a/parser/astfromxml_detail/nodereader_impl.h b/parser/astfromxml_detail/nodereader_impl.h
index 60bd3638..03eedd58 100644
--- a/parser/astfromxml_detail/nodereader_impl.h
+++ b/parser/astfromxml_detail/nodereader_impl.h
@@ -173,17 +173,18 @@ struct NodeReader<ConstantAst> : public BaseNodeReader<ConstantAst>
     }
 
     void readAttribute(AttributeTag<constant_type>, QStringRef const& value) {
+        auto data = std::get<QString>(result->value);
         if (value == "float") {
-            result->value = std::get<QString>(result->value).toFloat();
+            result->value = data.toFloat();
         }
         else if (value == "int") {
-            result->value = std::get<QString>(result->value).toInt();
+            result->value = data.toInt();
         }
         else if (value == "bytes") {
-            result->value = QByteArray::fromBase64(std::get<QString>(result->value).toUtf8());
+            result->value = QByteArray::fromBase64(data.toUtf8());
         }
         else if (value == "str") {
-            result->value = QString::fromUtf8(QByteArray::fromBase64(std::get<QString>(result->value).toUtf8())); // phew
+            result->value = QString::fromUtf8(QByteArray::fromBase64(data.toUtf8())); // phew
         }
         else if (value == "bool") {
             result->value = std::get<QString>(result->value) == "True" ? true : false;
-- 
GitLab


From 3b2187ccb84b1f239b208a4bb2e82bf6681a4cdf Mon Sep 17 00:00:00 2001
From: Sven Brauch <mail@svenbrauch.de>
Date: Mon, 21 Mar 2022 11:11:17 +0100
Subject: [PATCH 29/29] attempt to fix freebsd build

---
 parser/python_header.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/parser/python_header.h b/parser/python_header.h
index 225d97af..652b8908 100644
--- a/parser/python_header.h
+++ b/parser/python_header.h
@@ -10,6 +10,8 @@
 
 #define Py_BUILD_CORE
 
+#include <stdbool.h>
+
 // remove interfering qt macro
 #undef slots
 
-- 
GitLab

